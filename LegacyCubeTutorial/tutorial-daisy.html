<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Erno AI — Tutorial Daisy</title>
<style>
:root{
  --bg:#0b0c10; --panel:#121420; --ink:#e8eefc; --muted:#92a0b8; --line:#1b2133; --splashA:#11182a;
  /* derived; populated by JS too */
  --card:#0d1222; --chip:#16213a; --chipBorder:#22325a;
  --btn:#16233e; --btnBorder:#22325a; --accent:#6ea8ff;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
#brand{position:fixed;left:50%;top:12px;transform:translateX(-50%);font-weight:800;font-size:18px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:.4rem .6rem;backdrop-filter:blur(2px);z-index:10}
#topbar{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10}
#topright{position:fixed;right:12px;top:12px;z-index:10}
button{background:var(--btn);border:1px solid var(--btnBorder);color:var(--ink);border-radius:10px;padding:.55rem .8rem;font-weight:800;cursor:pointer}
button:hover{filter:brightness(1.07)}
button:disabled{opacity:.55;filter:grayscale(.2);cursor:not-allowed}

#stage{position:absolute;inset:0}
canvas{display:block;width:100%;height:100%; touch-action:none;}

/* Move Picker (theme-flexible) */
#movePicker{
  position:fixed;right:12px;bottom:12px;z-index:21;
  background:var(--card);color:var(--ink);border:1px solid var(--line);
  border-radius:12px;padding:8px;box-shadow:0 10px 24px rgba(0,0,0,.35);min-width:min(720px,92vw);backdrop-filter:blur(2px);
}
#movePicker h3{margin:0 0 6px 0;font-size:13px;font-weight:800}
#score{font-weight:800; margin-left:8px; opacity:.95}
.keygrid{display:flex;flex-wrap:wrap;gap:6px}
.btn-key{
  font-family:ui-monospace,Consolas,monospace;padding:.45rem .65rem;border-radius:10px;border:1px solid var(--btnBorder);
  background:var(--btn);color:var(--ink);font-weight:800;cursor:pointer;transition:filter .15s ease
}
.btn-key:hover{filter:brightness(1.07)}
.btn-key:focus{outline:2px solid #2f4fb3;outline-offset:1px}

/* Splash */
#splash{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 30%, var(--splashA) 0%, var(--bg) 60%);color:var(--ink);z-index:9999;transition:.4s}
#splash.hide{opacity:0;visibility:hidden}
#splash .inner{display:flex;flex-direction:column;align-items:center;gap:12px;text-align:center}
.spinner{width:36px;height:36px;border-radius:50%;border:3px solid rgba(255,255,255,.35);border-top-color:var(--ink);animation:spin .9s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* Themed confirm modal (for Main/back) */
.modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.45);display:none; place-items:center; z-index:1000; backdrop-filter:blur(2px);}
.modal{
  width:min(520px,92vw); background:var(--panel); color:var(--ink);
  border:1px solid var(--line); border-radius:14px; padding:16px; box-shadow:0 16px 40px rgba(0,0,0,.45);
}
.modal h3{margin:0 0 6px 0; font-size:18px}
.modal p{margin:0 0 12px 0; color:var(--muted)}
.modal .row{display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap}
.modal .btn{background:var(--btn); border:1px solid var(--btnBorder); color:var(--ink); border-radius:10px; padding:.55rem .9rem; font-weight:800; cursor:pointer;}
.btn-ghost{background:transparent; border:1px solid var(--btnBorder); color:var(--ink);}
.modal-backdrop.show{display:grid}

/* Coach overlays */
.coach{
  position:fixed; z-index:2000; pointer-events:none; color:var(--ink);
  font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  display:flex; flex-direction:column; align-items:center;
}
.coach .caption{
  background:var(--panel);
  border:1px solid var(--btnBorder);
  color:var(--ink);
  padding:.30rem .55rem;
  border-radius:8px;
  font-weight:800;
  white-space:nowrap;
  text-wrap:balance;
  max-width:36ch;
}
.coach .arrow{
  width:0;height:0;
  margin:4px 0;
  border:9px solid transparent;
  animation:bob 1.2s ease-in-out infinite;
  opacity:.95;
}
.coach.down .arrow{ border-top-color:var(--panel);}
.coach.up   .arrow{ border-bottom-color:var(--panel);}
@keyframes bob{ 0%,100%{ transform:translateY(0);} 50%{ transform:translateY(6px);} }
.hidden{display:none}

/* Intro Popup */
#introBackdrop{
  position:fixed; inset:0; display:none; place-items:center;
  background:rgba(0,0,0,.55); backdrop-filter:blur(2px);
  z-index:3000;
}
#introBackdrop.show{ display:grid; }
#introCard{
  width:min(940px,94vw); max-height:90vh; overflow:auto;
  background:var(--panel); color:var(--ink);
  border:1px solid var(--line); border-radius:16px;
  box-shadow:0 24px 64px rgba(0,0,0,.5);
}
#introCard header{
  position:sticky; top:0; z-index:1;
  display:flex; align-items:center; justify-content:space-between; gap:12px;
  padding:14px 16px; background:var(--panel); border-bottom:1px solid var(--line);
}
#introCard h2{ margin:0; font-size:20px }
#introClose{
  background:transparent; border:1px solid var(--btnBorder); padding:.35rem .55rem; border-radius:10px; font-weight:800
}
#introBody{ padding:16px }
.intro-grid{ display:grid; grid-template-columns: 1.1fr 1.4fr; gap:16px }
@media (max-width:900px){ .intro-grid{ grid-template-columns: 1fr } }
.intro-figure{
  background:var(--card); border:1px solid var(--line); border-radius:12px; padding:10px; display:grid; place-items:center
}
.intro-figure img{ max-width:100%; height:auto; border-radius:10px }
.intro-copy p{ margin:.2rem 0 .7rem 0; color:var(--ink) }
.intro-copy ul{ margin:.2rem 0 .8rem 1.1rem; color:var(--muted) }
.intro-foot{
  position:sticky; bottom:0; background:var(--panel);
  border-top:1px solid var(--line); padding:12px 16px; display:flex; gap:10px; justify-content:flex-end; align-items:center
}
label.inline{ display:flex; align-items:center; gap:.45rem; color:var(--muted); margin-right:auto }
</style>
</head>
<body>
<div id="splash">
  <div class="inner">
    <h1>Erno AI<span style="display:block;opacity:.85;font-size:14px;margin-top:6px">Loading Daisy…</span></h1>
    <div class="spinner" aria-hidden="true"></div>
  </div>
</div>

<div id="brand">Erno AI: Daisy</div>
<div id="topbar">
  <button id="btn-restart" title="Reset to original scramble">⟲ Restart</button>
  <button id="btn-main">Main Page</button>
  <button id="btn-check">Check Daisy</button>
  <button id="btn-instructions" title="Open instructions">Instructions</button>
</div>
<div id="topright">
  <button id="btn-continue" disabled aria-disabled="true" title="Get 4/4 to continue">Continue →</button>
</div>

<div id="stage"><canvas id="view"></canvas></div>

<div id="movePicker" role="group" aria-label="Move Picker">
  <h3>Move Picker <span id="score">(number of white edges in place: 0/4)</span></h3>
  <div id="moveGrid" class="keygrid"></div>
</div>

<!-- Confirm modal for Main -->
<div id="confirmWrap" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmDesc">
    <h3 id="confirmTitle">Leave this tutorial?</h3>
    <p id="confirmDesc">You'll lose your tutorial progress if you leave. Are you sure?</p>
    <div class="row">
      <button id="confirmCancel" class="btn btn-ghost">Cancel</button>
      <button id="confirmOk" class="btn">OK</button>
    </div>
  </div>
</div>

<!-- Coach: point at Check Daisy -->
<div id="coach-check" class="coach up" role="note" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Use this to check your Daisy Progress</div>
</div>
<div id="coach-moves" class="coach down" role="note" aria-live="polite">
  <div class="caption">Use the <b>Move Picker</b> or drag faces to turn the cube</div>
  <div class="arrow" aria-hidden="true"></div>
</div>

<!-- Coach under Continue (shown once it unlocks) -->
<div id="coach-continue" class="coach up hidden" role="status" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Congrats! Proceed when you are ready</div>
</div>

<!-- Intro Popup -->
<div id="introBackdrop" role="dialog" aria-modal="true" aria-labelledby="introTitle" aria-describedby="introDesc">
  <div id="introCard">
    <header>
      <h2 id="introTitle">Step 1: The <span style="color:var(--accent)">Daisy</span></h2>
      <button id="introClose" title="Close">✕</button>
    </header>
    <div id="introBody">
      <div class="intro-grid">
        <figure class="intro-figure">
          <img 
            src="https://images.squarespace-cdn.com/content/v1/54f2df67e4b079e94c291e4f/1427442852968-SDBN9BCCN5PIE9VY71BH/step1_rubiks_cube" 
            alt="Illustration of the Daisy: four white edge pieces surrounding the yellow center on the top face." />
        </figure>
        <div class="intro-copy" id="introDesc">
          <p><b>What is the Daisy?</b> It’s the pattern where the <b>yellow center</b> is on the top (U) face and the four <b>white edge pieces</b> surround it like petals. The white stickers point <b>up</b>.</p>
          <p><b>Why make it first?</b> From the Daisy, you can rotate each white edge above its matching side-center color and then flip it down to build a perfect <b>white cross</b>. This keeps things organized and avoids hunting for pieces later.</p>
          <p><b>What it looks like:</b> Top face shows a yellow center with four white edges around it. From the side, each of those white edges has a second color that should later match the center on that side (e.g., white–green lines up over the green center).</p>
          <ul>
            <li>Keep the <b>yellow center on top</b>. If it isn’t, rotate the whole cube so it is.</li>
            <li>Bring each white edge to the top without breaking ones already placed. Use gentle <code>U/R/L/F/D/B</code> turns.</li>
            <li>If a white edge is on the bottom layer, turn the bottom to place it below an open “petal” slot, then use a face turn to lift it up.</li>
            <li>Don’t worry about side color matching yet—just get all <b>four whites up around yellow</b>.</li>
          </ul>
          <p style="color:var(--muted)">Tip: If you knock a petal out, no stress—just put it back. Once you have <b>4/4</b>, press <b>Check Daisy</b> and then continue.</p>
          <p><b>Warning:</b> The move picker will not work as expected because the current LegacyCube model doesn't account for rotations. Drag moves will still work fine, but using <b>BetterCube Model</b> is highly recommended for the tutorial.</p>
        </div>
      </div>
    </div>
    <div class="intro-foot">
      <button id="introStart">Got it — Let’s start</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
// ===== Theme =====
const STORAGE_KEY='erno_theme_v1';
const THEMES = {
  default:{name:'Midnight (Default)',v:{bg:'#0b0c10',panel:'#121420',ink:'#e8eefc',muted:'#92a0b8',line:'#1b2133',splashA:'#11182a'}},
  cream:{name:'Cream',v:{bg:'#f4efe6',panel:'#fffaf2',ink:'#2c2a25',muted:'#6b665b',line:'#e1d9c9',splashA:'#efe7d8'}},
  caramel:{name:'Caramel',v:{bg:'#2a1f1a',panel:'#3b2b22',ink:'#f8e9d4',muted:'#d9c2a8',line:'#4c3a30',splashA:'#3a2a22'}},
  cyber:{name:'Cyber',v:{bg:'#0a0f0a',panel:'#0f1510',ink:'#d5ffd5',muted:'#90c990',line:'#183018',splashA:'#0f1c10'}},
  nord:{name:'Nord',v:{bg:'#2e3440',panel:'#3b4252',ink:'#eceff4',muted:'#c0c8d5',line:'#4c566a',splashA:'#323a49'}},
  dracula:{name:'Dracula',v:{bg:'#282a36',panel:'#1e2029',ink:'#f8f8f2',muted:'#b6b6c1',line:'#3b3e4b',splashA:'#2f3140'}},
  solarDark:{name:'Solarized Dark',v:{bg:'#002b36',panel:'#073642',ink:'#eee8d5',muted:'#93a1a1',line:'#0b3a46',splashA:'#03313c'}},
  solarLight:{name:'Solarized Light',v:{bg:'#fdf6e3',panel:'#f5efd9',ink:'#073642',muted:'#657b83',line:'#e6dec4',splashA:'#efe8d2'}},
  catMocha:{name:'Catppuccin Mocha',v:{bg:'#1e1e2e',panel:'#242437',ink:'#cdd6f4',muted:'#a6adc8',line:'#313244',splashA:'#23233a'}},
  gruvDark:{name:'Gruvbox Dark',v:{bg:'#1d2021',panel:'#282828',ink:'#ebdbb2',muted:'#d5c4a1',line:'#3c3836',splashA:'#232524'}},
  gruvLight:{name:'Gruvbox Light',v:{bg:'#fbf1c7',panel:'#f2e5bc',ink:'#3c3836',muted:'#7c6f64',line:'#e0d2a4',splashA:'#f5e8bf'}},
  oneDark:{name:'One Dark',v:{bg:'#21252b',panel:'#282c34',ink:'#e6efff',muted:'#a0afc1',line:'#323844',splashA:'#252a31'}},
  synthwave:{name:'Synthwave',v:{bg:'#1b1227',panel:'#231833',ink:'#fedaff',muted:'#d7b6ff',line:'#3a2857',splashA:'#23173a'}},
  monokai:{name:'Monokai',v:{bg:'#272822',panel:'#2e2f27',ink:'#f8f8f2',muted:'#c2c2b4',line:'#3b3c34',splashA:'#2c2d26'}},
  mint:{name:'Mint',v:{bg:'#0e1412',panel:'#111a16',ink:'#d9fff2',muted:'#9de5cf',line:'#173026',splashA:'#15231e'}},
  rosePine:{name:'Rosé Pine',v:{bg:'#191724',panel:'#1f1d2e',ink:'#e0def4',muted:'#908caa',line:'#2a2837',splashA:'#201e2f'}},
  highContrast:{name:'High Contrast',v:{bg:'#000000',panel:'#0a0a0a',ink:'#ffffff',muted:'#bfbfbf',line:'#222222',splashA:'#101010'}},
  mono:{name:'Monochrome',v:{bg:'#111114',panel:'#16171a',ink:'#f1f2f5',muted:'#a9acb3',line:'#272a33',splashA:'#1b1c20'}}
};
function hexToRgb(h){ h=h.replace('#',''); if(h.length===3) h=h.split('').map(c=>c+c).join(''); const n=parseInt(h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
function rgbToHex({r,g,b}){ const n=(r<<16)|(g<<8)|b; return '#'+n.toString(16).padStart(6,'0'); }
function mix(a,b,t){ const A=hexToRgb(a),B=hexToRgb(b); return rgbToHex({r:Math.round(A.r+(B.r-A.r)*t),g:Math.round(A.g+(B.g-A.g)*t),b:Math.round(A.b+(B.b-A.b)*t)}); }
function applyThemeVars(v){
  const rs=document.documentElement.style;
  const card = mix(v.panel, v.bg, 0.15);
  const chip = mix(v.panel, v.line, 0.35);
  const chipBorder = mix(v.line, v.panel, 0.4);
  const btn = mix(v.panel, v.line, 0.25);
  const btnBorder = mix(v.line, v.panel, 0.25);
  const splashA = v.splashA || v.panel;
  const accent = mix(v.ink, v.panel, 0.2);

  rs.setProperty('--bg', v.bg);
  rs.setProperty('--panel', v.panel);
  rs.setProperty('--ink', v.ink);
  rs.setProperty('--muted', v.muted);
  rs.setProperty('--line', v.line);
  rs.setProperty('--splashA', splashA);
  rs.setProperty('--card', card);
  rs.setProperty('--chip', chip);
  rs.setProperty('--chipBorder', chipBorder);
  rs.setProperty('--btn', btn);
  rs.setProperty('--btnBorder', btnBorder);
  rs.setProperty('--accent', accent);
}
function applyThemeById(id){ const t = THEMES[id] || THEMES.default; applyThemeVars(t.v); }
applyThemeById(localStorage.getItem(STORAGE_KEY) || 'default');
window.addEventListener('storage', (e)=>{ if(e.key===STORAGE_KEY) applyThemeById(e.newValue || 'default'); });

const splash=document.getElementById('splash');
function hideSplash(){ splash.classList.add('hide'); setTimeout(()=>splash.remove(),800); }
window.addEventListener('load', ()=> setTimeout(hideSplash, 400));

// ===== Modal for Main =====
const modal = document.getElementById('confirmWrap');
const okBtn = document.getElementById('confirmOk');
const cancelBtn = document.getElementById('confirmCancel');
function openConfirm(){ modal.classList.add('show'); modal.setAttribute('aria-hidden','false'); okBtn.focus(); }
function closeConfirm(){ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
modal.addEventListener('click', (e)=>{ if(e.target === modal) closeConfirm(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.classList.contains('show')) closeConfirm(); });
okBtn.addEventListener('click', ()=>{
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Returning to Main Page…';
  modal.classList.remove('show');
  setTimeout(()=>{ location.href = 'index.html'; }, 300);
});
cancelBtn.addEventListener('click', closeConfirm);

// ===== Scene =====
const canvas = document.getElementById('view');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50,1,.1,1000);
const CAM_INIT_POS = new THREE.Vector3(5.2, 4.7, 6.1);
const CAM_INIT_TARGET = new THREE.Vector3(0, 0, 0);
function resetView(){ camera.position.copy(CAM_INIT_POS); camera.lookAt(CAM_INIT_TARGET); }
resetView();
scene.add(camera);
scene.add(new THREE.AmbientLight(0xffffff,.6));
const key = new THREE.DirectionalLight(0xffffff,.9); key.position.set(3,6,7); scene.add(key);
const stage = document.getElementById('stage');
new ResizeObserver(()=>{ const w=stage.clientWidth,h=stage.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();}).observe(stage);

// Build cubies
const cubeGroup = new THREE.Group(); scene.add(cubeGroup);
let cubies=[]; const CELL=1, STICKER=.92, GAP=.04;
const COLORS={ U:0xffd500, D:0xffffff, L:0xcc0000, R:0xff8c1a, F:0x00a040, B:0x0040cc };
function mkCubie(i,j,k){
  const core = new THREE.Mesh(new THREE.BoxGeometry(STICKER,STICKER,STICKER), new THREE.MeshStandardMaterial({color:0x111317,roughness:.9}));
  const g=new THREE.Group(); g.add(core); g.position.set(i*CELL,j*CELL,k*CELL);
  const faces=[
    {key:'R',show:i===1,n:new THREE.Vector3(1,0,0)},
    {key:'L',show:i===-1,n:new THREE.Vector3(-1,0,0)},
    {key:'U',show:j===1,n:new THREE.Vector3(0,1,0)},
    {key:'D',show:j===-1,n:new THREE.Vector3(0,-1,0)},
    {key:'F',show:k===1,n:new THREE.Vector3(0,0,1)},
    {key:'B',show:k===-1,n:new THREE.Vector3(0,0,-1)}
  ];
  const pg=new THREE.PlaneGeometry(STICKER-GAP,STICKER-GAP);
  faces.forEach(f=>{
    if(!f.show) return;
    const s=new THREE.Mesh(pg,new THREE.MeshBasicMaterial({color:COLORS[f.key]}));
    s.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), f.n);
    s.position.copy(f.n).multiplyScalar(STICKER/2+0.001);
    s.userData = { isSticker:true, faceKey:f.key, localNormal:f.n.clone() };
    g.add(s);
  });
  cubeGroup.add(g); cubies.push(g);
}
(function build(){ for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) for(let k=-1;k<=1;k++) mkCubie(i,j,k); })();

// ===== Orbit & turning =====
let orbit=false, px=0, py=0;
canvas.addEventListener('contextmenu',e=>e.preventDefault(), {passive:false});
canvas.addEventListener('pointerdown',e=>{
  if(e.pointerType!=='mouse') return;
  // Right click OR Shift+Left = orbit
  if(e.button===2 || (e.button===0 && e.shiftKey)){
    orbit=true; px=e.clientX; py=e.clientY;
  }
},{passive:false});
canvas.addEventListener('pointerup',()=>{orbit=false;},{passive:false});
canvas.addEventListener('pointerleave',()=>{orbit=false;},{passive:false});
canvas.addEventListener('pointermove',e=>{
  if(!orbit) return;
  const dx=e.clientX-px,dy=e.clientY-py; px=e.clientX;py=e.clientY;
  const sp=0.005,target=new THREE.Vector3(0,0,0);
  const offset=camera.position.clone().sub(target);
  offset.applyAxisAngle(new THREE.Vector3(0,1,0),-dx*sp);
  const view=target.clone().sub(camera.position).normalize();
  let right=new THREE.Vector3().crossVectors(view,new THREE.Vector3(0,1,0));
  if(right.lengthSq()<1e-8) right=new THREE.Vector3(1,0,0); else right.normalize();
  offset.applyAxisAngle(right,-dy*sp);
  camera.position.copy(target.clone().add(offset));
  camera.lookAt(target);
},{passive:false});
window.addEventListener('wheel',e=>{
  camera.position.multiplyScalar(1+Math.sign(e.deltaY)*.08).clampLength(4,40);
},{passive:true});

const ANIM_MS = 85;
const AX={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};
let turning=false;
function animateTo(pivot, axisVec, start, target, sel, done){
  turning=true;
  const dur=ANIM_MS, t0=performance.now();
  const tick=t=>{
    const k=Math.min(1,(t-t0)/dur), ang=start+(target-start)*k;
    pivot.setRotationFromAxisAngle(axisVec,ang);
    renderer.render(scene,camera);
    if(k<1) requestAnimationFrame(tick);
    else {
      pivot.updateMatrixWorld(true);
      for(const c of sel){ cubeGroup.attach(c);
        c.position.set(Math.round(c.position.x),Math.round(c.position.y),Math.round(c.position.z)); }
      cubeGroup.remove(pivot);
      turning=false; done&&done();
    }
  };
  requestAnimationFrame(tick);
}
function select(axis,layer){ const out=[]; for(const c of cubies){ const v=axis==='x'?c.position.x:axis==='y'?c.position.y:c.position.z; if(Math.round(v)===layer) out.push(c);} return out; }
function rotate(axis,layer,sign,cb){ if(turning) return; const sel=select(axis,layer); const pivot=new THREE.Group(); cubeGroup.add(pivot); sel.forEach(c=>pivot.attach(c)); animateTo(pivot,AX[axis],0,sign*(Math.PI/2),sel,cb); }
function parseMove(lbl){
  const base = lbl.replace(/['2]/g,''); const suf = lbl.slice(base.length);
  let axis,layer,sign;
  switch(base){ case'R':axis='x';layer=+1;sign=(suf==="'")?-1:+1;break; case'L':axis='x';layer=-1;sign=(suf==="'")?+1:-1;break; case'U':axis='y';layer=+1;sign=(suf==="'")?-1:+1;break; case'D':axis='y';layer=-1;sign=(suf==="'")?+1:-1;break; case'F':axis='z';layer=+1;sign=(suf==="'")?-1:+1;break; case'B':axis='z';layer=-1;sign=(suf==="'")?+1:-1;break; case'M':axis='x';layer=0;sign=(suf==="'")?-1:+1;break; case'E':axis='y';layer=0;sign=(suf==="'")?-1:+1;break; case'S':axis='z';layer=0;sign=(suf=="'")?-1:+1;break; default:return null;}
  if(base!=='M'&&base!=='E') sign*=-1;
  const reps = (suf==='2')?2:1;
  return {axis,layer,sign,reps};
}
const labels=["R","R'","U","U'","F","F'","L","L'","D","D'","B","B'","M","M'","E","E'","S","S'"];
const moveGrid=document.getElementById('moveGrid');
labels.forEach(lbl=>{
  const b=document.createElement('button'); b.className='btn-key'; b.textContent=lbl;
  b.addEventListener('click', ()=>{
    const a=parseMove(lbl); if(!a) return;
    const go=(left)=>{ if(left<=0) return; rotate(a.axis,a.layer,a.sign, ()=>go(left-1)); }; go(a.reps);
  });
  moveGrid.appendChild(b);
});

// ===== Drag turning with Shift-lock =====
const ray=new THREE.Raycaster(), ndc=new THREE.Vector2();
const toNDC=e=>{ const r=canvas.getBoundingClientRect(); ndc.x=((e.clientX-r.left)/r.width)*2-1; ndc.y=-((e.clientY-r.top)/r.height)*2+1; };
function pick(e){ toNDC(e); ray.setFromCamera(ndc,camera); const hit=ray.intersectObjects(cubeGroup.children,true)[0]; if(!hit) return null; let root=hit.object; while(root && root.parent!==cubeGroup) root=root.parent; const n=hit.face?hit.face.normal.clone().transformDirection(hit.object.matrixWorld):new THREE.Vector3(0,0,1).applyQuaternion(hit.object.getWorldQuaternion(new THREE.Quaternion())); return {cubie:root,normal:n.normalize()}; }
const AXV={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};
function camBasis(){ const f=new THREE.Vector3(); camera.getWorldDirection(f); const r=new THREE.Vector3().crossVectors(f,camera.up).normalize().negate(); const u=new THREE.Vector3().crossVectors(r,f).normalize(); return {r,u}; }

let shiftLock=false; // NEW: while true, prevent any layer-turn drag

// If Shift gets pressed during a drag, cancel & snap back
function cancelDragSnapBack(){
  if(!drag.active) return;
  if(drag.pivot){
    // animate back to zero
    animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag());
  }else{
    resetDrag();
  }
}

window.addEventListener('keydown', (e)=>{
  if(e.key==='Shift'){
    if(!shiftLock){ shiftLock=true; cancelDragSnapBack(); }
  }
});
window.addEventListener('keyup', (e)=>{
  if(e.key==='Shift'){ shiftLock=false; }
});

const drag={active:false,sx:0,sy:0,axis:null,layer:0,sel:[],pivot:null,plus:null,angle:0};
function resetDrag(){ drag.active=false; drag.axis=null; drag.layer=0; drag.sel=[]; drag.pivot=null; drag.plus=null; drag.angle=0; }

const AXIS_LOCK_PX2_FACE=6,AXIS_LOCK_PX2_SLICE=3,SNAP_FRAC_FACE=.10,SNAP_FRAC_SLICE=.08,HALF=.75;

canvas.addEventListener('pointerdown',e=>{
  // Only left button starts a turn, AND not while Shift-lock is active
  if(e.pointerType==='mouse' && e.button!==0) return;
  if(shiftLock || e.shiftKey) return;       // NEW: ignore starting drag when Shift held
  if(turning) return;
  const info=pick(e); if(!info) return;
  drag.active=true; drag.sx=e.clientX; drag.sy=e.clientY; drag.axis=null;
});

canvas.addEventListener('pointermove',e=>{
  if(shiftLock){ cancelDragSnapBack(); return; }  // NEW: no turn while Shift held
  if(!drag.active||turning) return;

  const dx=e.clientX-drag.sx,dy=e.clientY-drag.sy,d2=dx*dx+dy*dy;
  if(!drag.axis){
    const infoPick = pick(e); if(!infoPick) return;
    const n=infoPick.normal;
    const cand=Math.abs(n.x)>0.8?['y','z']:Math.abs(n.y)>0.8?['x','z']:['x','y'];
    const {r,u}=camBasis(); const v=new THREE.Vector3(0,0,0).addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
    let axis=cand[0],best=-1; for(const a of cand){ const s=Math.abs(v.dot(AXV[a])); if(s>best){best=s; axis=a;}}

    const layerGuess = Math.max(-1,Math.min(1,Math.round(axis==='x'?infoPick.cubie.position.x:axis==='y'?infoPick.cubie.position.y:axis==='z'?infoPick.cubie.position.z:0)));
    const need=(layerGuess===0?AXIS_LOCK_PX2_SLICE:AXIS_LOCK_PX2_FACE); if(d2<need) return;

    drag.axis=axis; drag.layer=layerGuess; drag.sel=select(axis,layerGuess);
    drag.pivot=new THREE.Group(); cubeGroup.add(drag.pivot); drag.sel.forEach(c=>drag.pivot.attach(c));
    drag.plus=new THREE.Vector3().crossVectors(n,AXV[axis]).normalize();
  }
  const {r,u}=camBasis(); const dragWorld=new THREE.Vector3(0,0,0).addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
  const s=dragWorld.dot(drag.plus); drag.angle=THREE.MathUtils.clamp(s*Math.PI,-3.2,3.2);
  drag.pivot.setRotationFromAxisAngle(AXV[drag.axis], drag.angle); renderer.render(scene,camera);
});

function commitOrCancel(){
  if(!drag.axis || !drag.pivot){ resetDrag(); return; }
  const q=Math.PI/2, a=Math.abs(drag.angle), frac=(drag.layer===0?SNAP_FRAC_SLICE:SNAP_FRAC_FACE);
  if(a<q*frac){
    animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag());
  }else{
    let reps, sign;
    if(a>=Math.PI*HALF){ reps=2; sign=(drag.angle>0)?+1:-1; } else { reps=1; sign=(drag.angle>0)?+1:-1; }
    const go=(left)=>{ if(left<=0){ resetDrag(); return; } animateTo(drag.pivot, AXV[drag.axis], left===reps?drag.angle:0, sign*(Math.PI/2), drag.sel, ()=>go(left-1)); };
    go(reps);
  }
}
canvas.addEventListener('pointerup',()=>{
  if(shiftLock){ cancelDragSnapBack(); return; } // if released while Shift held, ensure no turn applied
  if(drag.active) commitOrCancel();
});
window.addEventListener('pointerup', ()=>{ if(drag.active) commitOrCancel(); });
canvas.addEventListener('pointercancel', ()=>{ if(!drag.active) return; animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag()); });

// ===== State I/O =====
function serializeState(){
  return cubies.map(c=>({ p:[c.position.x,c.position.y,c.position.z], q:[c.quaternion.x,c.quaternion.y,c.quaternion.z,c.quaternion.w] }));
}
function applyState(state){
  if(!state || state.length!==cubies.length) return false;
  for(let i=0;i<cubies.length;i++){
    const it=state[i], c=cubies[i];
    c.position.set(Math.round(it.p[0]), Math.round(it.p[1]), Math.round(it.p[2]));
    c.quaternion.set(it.q[0],it.q[1],it.q[2],it.q[3]);
    c.updateMatrixWorld(true);
  }
  return true;
}
function loadJSON(key){ try{ return JSON.parse(localStorage.getItem(key)||''); }catch(_){ return null; } }

// Load starting state
const startState = loadJSON('erno_firststeps_leave_state_v1') || loadJSON('erno_scramble_state_v1');
if(startState) applyState(startState);

// ===== Daisy check =====
const Y = new THREE.Vector3(0,1,0);
const WHITE = 0xffffff, YELLOW = 0xffd500;

function findCubieAt(x,y,z){
  for(const c of cubies){
    if(Math.round(c.position.x)===x && Math.round(c.position.y)===y && Math.round(c.position.z)===z) return c;
  }
  return null;
}
function stickerFacingUpColor(cubie){
  if(!cubie) return null;
  const q = cubie.getWorldQuaternion(new THREE.Quaternion());
  for(const ch of cubie.children){
    if(!ch.userData?.isSticker) continue;
    const n = ch.userData.localNormal.clone().applyQuaternion(q).normalize();
    if(n.y > 0.95){
      return ch.material.color.getHex();
    }
  }
  return null;
}
function yellowCenterOnTop(){
  const center = findCubieAt(0,1,0);
  const col = stickerFacingUpColor(center);
  return col === YELLOW;
}
function countDaisy(){
  if(!yellowCenterOnTop()) return 0;
  const targets = [
    findCubieAt( 1, 1, 0),
    findCubieAt(-1, 1, 0),
    findCubieAt( 0, 1, 1),
    findCubieAt( 0, 1,-1),
  ];
  let c=0;
  for(const e of targets){
    const col = stickerFacingUpColor(e);
    if(col === WHITE) c++;
  }
  return c;
}

// ===== UI wiring =====
const btnRestart = document.getElementById('btn-restart');
const btnMain = document.getElementById('btn-main');
const btnCheck = document.getElementById('btn-check');
const btnInstructions = document.getElementById('btn-instructions');
const btnContinue = document.getElementById('btn-continue');
const scoreEl = document.getElementById('score');
const coachCheck = document.getElementById('coach-check');
const coachMoves = document.getElementById('coach-moves');
const coachContinue = document.getElementById('coach-continue');

function placeCoach(coachEl, targetEl, where){
  if(!coachEl || !targetEl) return;
  const r = targetEl.getBoundingClientRect(), pad = 8;
  let left = r.left + r.width/2, top = r.top;
  if(where==='below'){
    coachEl.classList.remove('down'); coachEl.classList.add('up');
    top = r.bottom + 4; left = r.left + r.width/2; coachEl.style.transform = 'translate(-50%, 0)';
  }else if(where==='above'){
    coachEl.classList.remove('up'); coachEl.classList.add('down');
    top = r.top - coachEl.offsetHeight - pad; left = r.left + 16; coachEl.style.transform = 'translate(0, 0)';
  }
  coachEl.style.top = `${Math.max(8, top)}px`; coachEl.style.left = `${Math.max(8, left)}px`;
}
function positionCoaches(){
  placeCoach(coachCheck, btnCheck, 'below');
  placeCoach(coachMoves, document.getElementById('movePicker'), 'above');
  if(!btnContinue.disabled && !coachContinue.classList.contains('hidden')){
    placeCoach(coachContinue, btnContinue, 'below');
  }
}
window.addEventListener('resize', positionCoaches);
setTimeout(positionCoaches, 0);

function setScore(v){ scoreEl.textContent = `(number of white edges in place: ${v}/4)`; }
function toggleContinueCoach(show){
  coachContinue.classList.toggle('hidden', !show);
  if(show) { placeCoach(coachContinue, btnContinue, 'below'); }
}
function lockContinue(lock=true){
  btnContinue.disabled = lock;
  if(lock) btnContinue.setAttribute('aria-disabled','true');
  else btnContinue.removeAttribute('aria-disabled');
  toggleContinueCoach(!lock);
}

btnCheck.addEventListener('click', ()=>{
  const n = countDaisy();
  setScore(n);
  if(n===4){ lockContinue(false); }
  else{ lockContinue(true); }
});

btnContinue.addEventListener('click', ()=>{
  toggleContinueCoach(false);
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Continuing…';
  setTimeout(()=>{ location.href = 'tutorial-basics.html'; }, 300);
});

btnMain.addEventListener('click', openConfirm);
btnInstructions.addEventListener('click', ()=>{ openIntro(); });

btnRestart.addEventListener('click', ()=>{
  const seed = loadJSON('erno_scramble_state_v1');
  if(seed) applyState(seed);
  setScore(0);
  lockContinue(true);
});

// Render loop
(function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();

// Intro popup logic
const INTRO_KEY='erno_daisy_intro_seen_v1';
const introBackdrop=document.getElementById('introBackdrop');
const introClose=document.getElementById('introClose');
const introStart=document.getElementById('introStart');
function openIntro(){ introBackdrop.classList.add('show'); }
function closeIntro(){ introBackdrop.classList.remove('show'); }
introClose.addEventListener('click', closeIntro);
introStart.addEventListener('click', closeIntro);
introBackdrop.addEventListener('click', (e)=>{ if(e.target===introBackdrop) closeIntro(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && introBackdrop.classList.contains('show')) closeIntro(); });

window.addEventListener('load', ()=>{
  setTimeout(()=>{ if(localStorage.getItem(INTRO_KEY)!=='1') openIntro(); }, 700);
});
})();
</script>
</body>
</html>
