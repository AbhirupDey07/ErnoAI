<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Erno AI — Tutorial First Steps (Adaptive)</title>
<style>
:root{
--bg:#0b0c10; --panel:#121420; --ink:#e8eefc; --muted:#92a0b8; --line:#1b2133; --splashA:#11182a;
--card:#0d1222; --btn:#16233e; --btnBorder:#22325a;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
#brand{position:fixed;left:50%;top:12px;transform:translateX(-50%);font-weight:800;font-size:18px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:.4rem .6rem;backdrop-filter:blur(2px);z-index:10}
#topbar{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10}
#topright{position:fixed;right:12px;top:12px;z-index:10}
button{background:var(--btn);border:1px solid var(--btnBorder);color:var(--ink);border-radius:10px;padding:.55rem .8rem;font-weight:800;cursor:pointer}
button:hover{filter:brightness(1.07)}
button:disabled{opacity:.55;filter:grayscale(.2);cursor:not-allowed}

#stage{position:absolute;inset:0}
canvas{display:block;width:100%;height:100%; touch-action:none;}

/* Move Picker — updated to the “new keyboard” style */
#movePicker{position:fixed;right:12px;bottom:12px;z-index:21;background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:12px;padding:8px;box-shadow:0 10px 24px rgba(0,0,0,.35);width:clamp(320px,34vw,520px);height:clamp(320px,34vw,520px);display:flex;flex-direction:column;}
#movePicker h3{margin:0 0 8px 0;font-size:13px;font-weight:800;flex:0 0 auto}
.keygrid{display:grid;grid-template-columns:repeat(6,1fr);grid-auto-rows:1fr;gap:6px;flex:1;min-height:0}
.btn-key{font-family:ui-monospace,Consolas,monospace;display:grid;place-items:center;border-radius:10px;border:1px solid var(--btnBorder);background:var(--btn);color:var(--ink);font-weight:800;cursor:pointer;transition:filter .15s ease;font-size:13px;line-height:1;padding:0;min-height:0;min-width:0;width:100%;height:100%;}
.btn-key:hover{filter:brightness(1.07)}
.btn-key:focus{outline:2px solid #2f4fb3;outline-offset:1px}

/* Splash (for transitions) */
#splash{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 30%, var(--splashA) 0%, var(--bg) 60%);color:var(--ink);z-index:9999;transition:.4s}
#splash.hide{opacity:0;visibility:hidden}
#splash .inner{display:flex;flex-direction:column;align-items:center;gap:12px;text-align:center}
.spinner{width:36px;height:36px;border-radius:50%;border:3px solid rgba(255,255,255,.35);border-top-color:var(--ink);animation:spin .9s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* Themed confirm modal */
.modal-backdrop{
position:fixed; inset:0; background:rgba(0,0,0,.45);
display:none; place-items:center; z-index:1000; backdrop-filter:blur(2px);
}
.modal{
width:min(520px,92vw); background:var(--panel); color:var(--ink);
border:1px solid var(--line); border-radius:14px; padding:16px;
box-shadow:0 16px 40px rgba(0,0,0,.45);
}
.modal h3{margin:0 0 6px 0; font-size:18px}
.modal p{margin:0 0 12px 0; color:var(--muted)}
.modal .row{display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap}
.modal .btn{
background:var(--btn); border:1px solid var(--btnBorder); color:var(--ink);
border-radius:10px; padding:.55rem .9rem; font-weight:800; cursor:pointer;
}
.btn-ghost{
background:transparent; border:1px solid var(--btnBorder); color:var(--ink);
}
.modal-backdrop.show{display:grid}

/* --- Coach arrows / captions (consistent with Daisy) --- */
.coach{
  position:fixed; z-index:2000; pointer-events:none; color:var(--ink);
  font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  display:flex; flex-direction:column; align-items:center;
}
.coach .caption{
  background:var(--panel);
  border:1px solid var(--btnBorder);
  color:var(--ink);
  padding:.30rem .55rem;
  border-radius:8px;
  font-weight:800;
  white-space:nowrap;
  text-wrap:balance;
  max-width:36ch;
}
.coach .arrow{
  width:0;height:0;
  margin:4px 0;
  border:9px solid transparent;
  animation:bob 1.2s ease-in-out infinite;
  opacity:.95;
}
.coach.down .arrow   { border-top-color:var(--panel);} 
.coach.up   .arrow   { border-bottom-color:var(--panel);} 
.coach.left .arrow   { border-right-color:var(--panel);}  
.coach.right .arrow  { border-left-color:var(--panel);}  

@keyframes bob{ 0%,100%{ transform:translateY(0);} 50%{ transform:translateY(6px);} }
.hidden{display:none}
</style>
</head>
<body>
<div id="splash">
  <div class="inner">
    <h1>Erno AI<span style="display:block;opacity:.85;font-size:14px;margin-top:6px">Loading First Steps…</span></h1>
    <div class="spinner" aria-hidden="true"></div>
  </div>
</div>

<div id="brand">Erno AI: First Steps</div>
<div id="topbar">
  <button id="btn-back">← Back</button>
  <button id="btn-main">Main Page</button>
  <button id="btn-scramble">Scramble Cube</button>
</div>
<div id="topright">
  <button id="btn-continue" disabled aria-disabled="true" title="Press Scramble first">Continue →</button>
</div>

<div id="stage"><canvas id="view"></canvas></div>

<div id="movePicker" role="group" aria-label="Move Picker">
  <h3>Move Picker <span style="opacity:.8">(Adaptive)</span></h3>
  <div id="moveGrid" class="keygrid"></div>
</div>

<!-- Themed confirm modal -->
<div id="confirmWrap" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmDesc">
    <h3 id="confirmTitle">Leave this tutorial?</h3>
    <p id="confirmDesc">You'll lose your tutorial progress if you leave. Are you sure?</p>
    <div class="row">
      <button id="confirmCancel" class="btn btn-ghost">Cancel</button>
      <button id="confirmOk" class="btn">OK</button>
    </div>
  </div>
</div>

<!-- Coach overlays -->
<div id="coach-scramble" class="coach up hidden" role="note" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Your journey begins here</div>
</div>
<div id="coach-moves" class="coach down hidden" role="note" aria-live="polite">
  <div class="caption">Use the <b>Move Picker</b> Keyboard (or manually drag the faces with your finger/mouse) to feel how the cube turns</div>
  <div class="arrow" aria-hidden="true"></div>
</div>

<!-- FIXED: arrow now above the caption for the Continue hint -->
<div id="coach-continue" class="coach down hidden" role="note" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Proceed when you are ready</div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
/* ---------- Theme plumbed like index.html (derived vars set) ---------- */
(function(){
const THEMES={
  default:{v:{bg:'#0b0c10',panel:'#121420',ink:'#e8eefc',muted:'#92a0b8',line:'#1b2133',splashA:'#11182a'}},
  cream:{v:{bg:'#f4efe6',panel:'#fffaf2',ink:'#2c2a25',muted:'#6b665b',line:'#e1d9c9',splashA:'#efe7d8'}},
  caramel:{v:{bg:'#2a1f1a',panel:'#3b2b22',ink:'#f8e9d4',muted:'#d9c2a8',line:'#4c3a30',splashA:'#3a2a22'}},
  cyber:{v:{bg:'#0a0f0a',panel:'#0f1510',ink:'#d5ffd5',muted:'#90c990',line:'#183018',splashA:'#0f1c10'}},
  nord:{v:{bg:'#2e3440',panel:'#3b4252',ink:'#eceff4',muted:'#c0c8d5',line:'#4c566a',splashA:'#323a49'}},
  dracula:{v:{bg:'#282a36',panel:'#1e2029',ink:'#f8f8f2',muted:'#b6b6c1',line:'#3b3e4b',splashA:'#2f3140'}},
  solarDark:{v:{bg:'#002b36',panel:'#073642',ink:'#eee8d5',muted:'#93a1a1',line:'#0b3a46',splashA:'#03313c'}},
  solarLight:{v:{bg:'#fdf6e3',panel:'#f5efd9',ink:'#073642',muted:'#657b83',line:'#e0d2a4',splashA:'#efe8d2'}},
  catMocha:{v:{bg:'#1e1e2e',panel:'#242437',ink:'#cdd6f4',muted:'#a6adc8',line:'#313244',splashA:'#23233a'}},
  gruvDark:{v:{bg:'#1d2021',panel:'#282828',ink:'#ebdbb2',muted:'#d5c4a1',line:'#3c3836',splashA:'#232524'}},
  gruvLight:{v:{bg:'#fbf1c7',panel:'#f2e5bc',ink:'#3c3836',muted:'#7c6f64',line:'#e0d2a4',splashA:'#f5e8bf'}},
  oneDark:{v:{bg:'#21252b',panel:'#282c34',ink:'#e6efff',muted:'#a0afc1',line:'#323844',splashA:'#252a31'}},
  synthwave:{v:{bg:'#1b1227',panel:'#231833',ink:'#fedaff',muted:'#d7b6ff',line:'#3a2857',splashA:'#23173a'}},
  monokai:{v:{bg:'#272822',panel:'#2e2f27',ink:'#f8f8f2',muted:'#c2c2b4',line:'#3b3c34',splashA:'#2c2d26'}},
  mint:{v:{bg:'#0e1412',panel:'#111a16',ink:'#d9fff2',muted:'#9de5cf',line:'#173026',splashA:'#15231e'}},
  rosePine:{v:{bg:'#191724',panel:'#1f1d2e',ink:'#e0def4',muted:'#908caa',line:'#2a2837'}},
  highContrast:{v:{bg:'#000000',panel:'#0a0a0a',ink:'#ffffff',muted:'#bfbfbf',line:'#222222',splashA:'#101010'}},
  mono:{v:{bg:'#111114',panel:'#16171a',ink:'#f1f2f5',muted:'#a9acb3',line:'#272a33',splashA:'#1b1c20'}}
};
function hexToRgb(h){h=h.replace('#','');if(h.length===3)h=h.split('').map(c=>c+c).join('');const n=parseInt(h,16);return{r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
function rgbToHex({r,g,b}){const n=(r<<16)|(g<<8)|b;return'#'+n.toString(16).padStart(6,'0');}
function mix(a,b,t){const A=hexToRgb(a),B=hexToRgb(b);return rgbToHex({r:Math.round(A.r+(B.r-A.r)*t),g:Math.round(A.g+(B.g-A.g)*t),b:Math.round(A.b+(B.b-A.b)*t)});}
function apply(id){
  const v=(THEMES[id]||THEMES.default).v;
  const rs=document.documentElement.style;
  rs.setProperty('--bg',v.bg); rs.setProperty('--panel',v.panel); rs.setProperty('--ink',v.ink);
  rs.setProperty('--muted',v.muted); rs.setProperty('--line',v.line); rs.setProperty('--splashA',v.splashA||v.panel);
  rs.setProperty('--card', mix(v.panel, v.bg, 0.15));
  rs.setProperty('--btn', mix(v.panel, v.line, 0.25));
  rs.setProperty('--btnBorder', mix(v.line, v.panel, 0.25));
}
apply(localStorage.getItem('erno_theme_v1')||'default');
})();;

const splash=document.getElementById('splash');
function hideSplash(){ splash.classList.add('hide'); setTimeout(()=>splash.remove(),800); }
window.addEventListener('load', ()=> setTimeout(hideSplash, 500));

/* ---------- Themed modal wiring ---------- */
const modal = document.getElementById('confirmWrap');
const okBtn = document.getElementById('confirmOk');
const cancelBtn = document.getElementById('confirmCancel');
let leaveDest = null; // 'main' | 'basics'

function openConfirm(dest){
  leaveDest = dest;
  modal.classList.add('show');
  modal.setAttribute('aria-hidden','false');
  okBtn.focus();
}
function closeConfirm(){
  modal.classList.remove('show');
  modal.setAttribute('aria-hidden','true');
  leaveDest = null;
}
modal.addEventListener('click', (e)=>{ if(e.target === modal) closeConfirm(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.classList.contains('show')) closeConfirm(); });

okBtn.addEventListener('click', ()=>{
  if(!leaveDest) return;
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = leaveDest==='main' ? 'Returning to Main Page…' : 'Returning to Basics…';
  modal.classList.remove('show');
  setTimeout(()=>{ location.href = leaveDest==='main' ? 'adaptive-move-picker.h' : 'adaptive-tutorial-basics.html'; }, 300);
});
cancelBtn.addEventListener('click', closeConfirm);

document.getElementById('btn-back').addEventListener('click', ()=> openConfirm('basics'));
document.getElementById('btn-main').addEventListener('click', ()=> openConfirm('main'));

/* ---------- Minimal cube scene (Adaptive model) ---------- */
const canvas = document.getElementById('view');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50,1,.1,1000);
const CAM_INIT_POS = new THREE.Vector3(5.2, 4.7, 6.1);
const CAM_INIT_TARGET = new THREE.Vector3(0, 0, 0);
function resetView(){ camera.up.set(0,1,0); camera.position.copy(CAM_INIT_POS); camera.lookAt(CAM_INIT_TARGET); }
resetView();
scene.add(camera);
scene.add(new THREE.AmbientLight(0xffffff,.6));
const key = new THREE.DirectionalLight(0xffffff,.9); key.position.set(3,6,7); scene.add(key);
const stage = document.getElementById('stage');
new ResizeObserver(()=>{ const w=stage.clientWidth,h=stage.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();}).observe(stage);

/* Subtle background grid cube for depth */
(function makeGridCube(size=600,divisions=120,color=0x223355,opacity=0.07){
  const mk=()=>{const gh=new THREE.GridHelper(size,divisions,color,color);gh.material.transparent=true;gh.material.opacity=opacity;return gh};
  const g=new THREE.Group(), xz1=mk(), xz2=mk(), xy1=mk(), xy2=mk(), yz1=mk(), yz2=mk();
  xz1.position.y= size/2; xz2.position.y=-size/2; xy1.rotation.x=Math.PI/2; xy1.position.z= size/2; xy2.rotation.x=Math.PI/2; xy2.position.z=-size/2; yz1.rotation.z=Math.PI/2; yz1.position.x= size/2; yz2.rotation.z=Math.PI/2; yz2.position.x=-size/2;
  g.add(xz1,xz2,xy1,xy2,yz1,yz2); scene.add(g);
})();

/* ----- Build the cube ----- */
const cubeGroup = new THREE.Group(); scene.add(cubeGroup);
let cubies=[]; const CELL=1, STICKER=.92, GAP=.04;
const COLORS={ U:0xffd500, D:0xffffff, L:0xcc0000, R:0xff8c1a, F:0x00a040, B:0x0040cc };
function mkCubie(i,j,k){
  const core = new THREE.Mesh(new THREE.BoxGeometry(STICKER,STICKER,STICKER), new THREE.MeshStandardMaterial({color:0x111317,roughness:.9}));
  const g=new THREE.Group(); g.add(core); g.position.set(i*CELL,j*CELL,k*CELL);
  const faces=[{key:'R',show:i===1,n:new THREE.Vector3(1,0,0)},{key:'L',show:i===-1,n:new THREE.Vector3(-1,0,0)},{key:'U',show:j===1,n:new THREE.Vector3(0,1,0)},{key:'D',show:j===-1,n:new THREE.Vector3(0,-1,0)},{key:'F',show:k===1,n:new THREE.Vector3(0,0,1)},{key:'B',show:k===-1,n:new THREE.Vector3(0,0,-1)}];
  const pg=new THREE.PlaneGeometry(STICKER-GAP,STICKER-GAP);
  faces.forEach(f=>{ if(!f.show) return; const s=new THREE.Mesh(pg,new THREE.MeshBasicMaterial({color:COLORS[f.key]})); s.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), f.n); s.position.copy(f.n).multiplyScalar(STICKER/2+0.001); g.add(s); });
  cubeGroup.add(g); cubies.push(g);
}
(function build(){ for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) for(let k=-1;k<=1;k++) mkCubie(i,j,k); })();

/* ---------- Orbit (right-drag or Shift+LMB) ---------- */
let orbit=false, px=0, py=0;
canvas.addEventListener('contextmenu',e=>e.preventDefault(), {passive:false});
canvas.addEventListener('pointerdown',e=>{ if(e.pointerType!=='mouse') return; if(e.button===2||(e.button===0&&e.shiftKey)){orbit=true;px=e.clientX;py=e.clientY;} },{passive:false});
canvas.addEventListener('pointerup',()=>{orbit=false;},{passive:false});
canvas.addEventListener('pointerleave',()=>{orbit=false;},{passive:false});
function orbitStep(dx,dy){
  const sp=0.005, target=CAM_INIT_TARGET.clone();
  const f=new THREE.Vector3(); camera.getWorldDirection(f);
  const worldUp=new THREE.Vector3(0,1,0);
  const qYaw=new THREE.Quaternion().setFromAxisAngle(worldUp, -dx*sp);
  const rightV=new THREE.Vector3().crossVectors(f,camera.up).normalize();
  const safeRight = rightV.lengthSq()>1e-8 ? rightV : new THREE.Vector3(1,0,0);
  const qPitch=new THREE.Quaternion().setFromAxisAngle(safeRight, -dy*sp);
  const q=new THREE.Quaternion().multiply(qYaw).multiply(qPitch);
  const off=camera.position.clone().sub(target).applyQuaternion(q);
  camera.up.applyQuaternion(q);
  camera.position.copy(target.add(off));
  camera.lookAt(CAM_INIT_TARGET);
}
canvas.addEventListener('pointermove',e=>{ if(!orbit)return; const dx=e.clientX-px,dy=e.clientY-py; px=e.clientX;py=e.clientY; orbitStep(dx,dy); renderer.render(scene,camera); },{passive:false});
window.addEventListener('wheel',e=>{ camera.position.multiplyScalar(1+Math.sign(e.deltaY)*.08).clampLength(4,40); },{passive:true});

/* ---------- Picker + turning core (Adaptive) ---------- */
const AX={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};
let turning=false;
function animateTo(pivot, axisVec, start, target, sel, done){
  turning=true;
  const dur=Math.max(50, 240 - 31*5); // same speed as original tutorial (fixed ~31)
  const t0=performance.now();
  const tick=t=>{ const k=Math.min(1,(t-t0)/dur), ang=start+(target-start)*k; pivot.setRotationFromAxisAngle(axisVec,ang); renderer.render(scene,camera);
    if(k<1) requestAnimationFrame(tick); else { pivot.updateMatrixWorld(true); for(const c of sel){ cubeGroup.attach(c); c.position.set(Math.round(c.position.x),Math.round(c.position.y),Math.round(c.position.z)); } cubeGroup.remove(pivot); turning=false; done&&done(); } };
  requestAnimationFrame(tick);
}
function select(axis,layer){ const out=[]; for(const c of cubies){ const v=axis==='x'?c.position.x:axis==='y'?c.position.y:c.position.z; if(Math.round(v)===layer) out.push(c);} return out; }
function rotate(axis,layer,sign,cb){ if(turning) return; const sel=select(axis,layer); const pivot=new THREE.Group(); cubeGroup.add(pivot); sel.forEach(c=>pivot.attach(c)); animateTo(pivot,AX[axis],0,sign*(Math.PI/2),sel,cb); }
function rotateWhole(axis,sign,reps,cb){ if(turning) return; const sel=cubies.slice(); const pivot=new THREE.Group(); cubeGroup.add(pivot); sel.forEach(c=>pivot.attach(c));
  const step=(left)=>{ if(left<=0){ cb&&cb(); return; } animateTo(pivot,AX[axis],0,sign*(Math.PI/2),sel,()=>step(left-1)); };
  step(reps||1);
}

/* ---------- Drag turning (kept from tutorial, with guards) ---------- */
const ray=new THREE.Raycaster(), ndc=new THREE.Vector2();
const toNDC=e=>{ const r=canvas.getBoundingClientRect(); ndc.x=((e.clientX-r.left)/r.width)*2-1; ndc.y=-((e.clientY-r.top)/r.height)*2+1; };
function pick(e){ toNDC(e); ray.setFromCamera(ndc,camera); const hit=ray.intersectObjects(cubeGroup.children,true)[0]; if(!hit) return null; let root=hit.object; while(root && root.parent!==cubeGroup) root=root.parent; const n=hit.face?hit.face.normal.clone().transformDirection(hit.object.matrixWorld):new THREE.Vector3(0,0,1).applyQuaternion(hit.object.getWorldQuaternion(new THREE.Quaternion())); return {cubie:root,normal:n.normalize()}; }
function camBasis(){ const f=new THREE.Vector3(); camera.getWorldDirection(f).normalize(); const r=new THREE.Vector3().crossVectors(f,camera.up).normalize(); const u=new THREE.Vector3().crossVectors(r,f).normalize(); return {f,r,u}; }
const AXV={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};
const drag={active:false,sx:0,sy:0,axis:null,layer:0,sel:[],pivot:null,plus:null,angle:0};
function resetDrag(){ drag.active=false; drag.axis=null; drag.layer=0; drag.sel=[]; drag.pivot=null; drag.plus=null; drag.angle=0; }

const AXIS_LOCK_PX2_FACE=6,AXIS_LOCK_PX2_SLICE=3,SNAP_FRAC_FACE=.10,SNAP_FRAC_SLICE=.08,HALF=.75;
canvas.addEventListener('pointerdown',e=>{
  if(e.pointerType==='mouse' && e.button!==0) return;
  if(turning) return;
  const info=pick(e); if(!info) return; drag.active=true; drag.sx=e.clientX; drag.sy=e.clientY; drag.axis=null;
});
canvas.addEventListener('pointermove',e=>{
  if(!drag.active||turning) return;
  const dx=e.clientX-drag.sx,dy=e.clientY-drag.sy,d2=dx*dx+dy*dy;
  if(!drag.axis){
    const n=pick(e)?.normal||new THREE.Vector3(0,0,1);
    const cand=Math.abs(n.x)>0.8?['y','z']:Math.abs(n.y)>0.8?['x','z']:['x','y'];
    const {r,u}=camBasis(); const v=new THREE.Vector3(0,0,0).addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
    let axis=cand[0],best=-1; for(const a of cand){ const s=Math.abs(v.dot(AXV[a])); if(s>best){best=s; axis=a;}}
    const info2=pick(e); if(!info2) return;
    const layerGuess = Math.max(-1,Math.min(1,Math.round(axis==='x'?info2.cubie.position.x:axis==='y'?info2.cubie.position.y:info2.cubie.position.z)));
    const need=(layerGuess===0?AXIS_LOCK_PX2_SLICE:AXIS_LOCK_PX2_FACE); if(d2<need) return;
    drag.axis=axis; drag.layer=layerGuess; drag.sel=select(axis,layerGuess); drag.pivot=new THREE.Group(); cubeGroup.add(drag.pivot); drag.sel.forEach(c=>drag.pivot.attach(c));
    drag.plus=new THREE.Vector3().crossVectors(n,AXV[axis]).normalize();
  }
  const {r,u}=camBasis(); const dragWorld=new THREE.Vector3(0,0,0).addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
  const s=dragWorld.dot(drag.plus); drag.angle=THREE.MathUtils.clamp(s*Math.PI,-3.2,3.2);
  drag.pivot.setRotationFromAxisAngle(AXV[drag.axis], drag.angle); renderer.render(scene,camera);
});
function commitOrCancel(){
  if(!drag.axis || !drag.pivot){ resetDrag(); return; }
  const q=Math.PI/2, a=Math.abs(drag.angle);
  const frac=(drag.layer===0?SNAP_FRAC_SLICE:SNAP_FRAC_FACE);
  if(a<q*frac){
    animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag());
  }else{
    let reps, sign;
    if(a>=Math.PI*HALF){ reps=2; sign=(drag.angle>0)?+1:-1; }
    else{ reps=1; sign=(drag.angle>0)?+1:-1; }
    const go=(left)=>{
      if(left<=0){ resetDrag(); return; }
      animateTo(drag.pivot, AXV[drag.axis], left===reps ? drag.angle : 0, sign*(Math.PI/2), drag.sel, ()=>go(left-1));
    };
    go(reps);
  }
}
canvas.addEventListener('pointerup',()=>{ if(drag.active) commitOrCancel(); });
window.addEventListener('pointerup', ()=>{ if(drag.active) commitOrCancel(); });
canvas.addEventListener('pointercancel', ()=>{ if(!drag.active) return; if(!drag.axis || !drag.pivot){ resetDrag(); return; } animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag()); });

/* ---------- Adaptive mapping (from Adaptive Move Picker) ---------- */
function majorAxis(v){ const ax=Math.abs(v.x),ay=Math.abs(v.y),az=Math.abs(v.z); if(ax>=ay && ax>=az) return {axis:'x', sgn:v.x>=0?+1:-1}; if(ay>=ax && ay>=az) return {axis:'y', sgn:v.y>=0?+1:-1}; return {axis:'z', sgn:v.z>=0?+1:-1}; }
function viewMapping(){
  const {f,r,u}=camBasis();
  const Rm=majorAxis(r), Um=majorAxis(u), Fm=majorAxis(new THREE.Vector3(-f.x,-f.y,-f.z));
  const map={
    R:{axis:Rm.axis, layer:Rm.sgn>0?+1:-1, sgn:Rm.sgn}, L:{axis:Rm.axis, layer:Rm.sgn>0?-1:+1, sgn:-Rm.sgn},
    U:{axis:Um.axis, layer:Um.sgn>0?+1:-1, sgn:Um.sgn}, D:{axis:Um.axis, layer:Um.sgn>0?-1:+1, sgn:-Um.sgn},
    F:{axis:Fm.axis, layer:Fm.sgn>0?+1:-1, sgn:Fm.sgn}, B:{axis:Fm.axis, layer:Fm.sgn>0?-1:+1, sgn:-Fm.sgn}
  };
  map.M={axis:map.R.axis, layer:0, sgn:map.L.sgn};
  map.E={axis:map.U.axis, layer:0, sgn:map.D.sgn};
  map.S={axis:map.F.axis, layer:0, sgn:map.F.sgn};
  return map;
}
function labelFromAction(axis,layer,sign,reps=1){
  const m=viewMapping();
  const matchFace=(axis,layer)=>{
    const letters=['R','L','U','D','F','B'];
    for(const L of letters){ const e=m[L]; if(e.axis===axis && e.layer===layer) return L; }
    if(layer===0){ if(m.R.axis===axis) return 'M'; if(m.U.axis===axis) return 'E'; if(m.F.axis===axis) return 'S'; }
    return axis==='x'?(layer>0?'R':layer<0?'L':'M'):axis==='y'?(layer>0?'U':layer<0?'D':'E'):(layer>0?'F':layer<0?'B':'S');
  };
  const letter=matchFace(axis,layer), entry=m[letter], isSlice=(letter==='M'||letter==='E'||letter==='S');
  let cw=isSlice ? (sign=== entry.sgn) : (sign===-entry.sgn);
  if(letter==='E'||letter==='S'||letter==='M') cw=!cw; /* flip M/E/S sense */
  const suf=reps===2?'2':(cw?'':"'"); return letter+suf;
}
function moveToAction(letter,suffix){
  const M=viewMapping()[letter];
  let reps=1, cw=true;
  if(suffix==="2"){ reps=2; cw=true; }
  else if(suffix=="'"){ cw=false; }
  if(letter==='E'||letter==='S'||letter==='M') cw=!cw; /* flip M/E/S sense */
  const isSlice=(letter==='M'||letter==='E'||letter==='S');
  const sign=isSlice ? (cw?+M.sgn:-M.sgn) : (cw?-M.sgn:+M.sgn);
  return {axis:M.axis, layer:M.layer, sign, reps};
}

/* ---------- Move Picker (new keyboard incl. x/y/z) ---------- */
const labels=[
  'R',"R'", 'U',"U'", 'F',"F'", 'L',"L'", 'D',"D'", 'B',"B'",
  'M',"M'", 'E',"E'", 'S',"S'",
  'x',"x'", 'y',"y'", 'z',"z'"
];
const moveGrid=document.getElementById('moveGrid');
function applyLabel(lbl, cb){
  if(turning) return;
  const m=/^([RULDFBMESxyz])([2']?)$/.exec(lbl);
  if(!m) return;
  const letter=m[1], suf=m[2]||'';
  if('xyz'.includes(letter)){
    const axis=letter, reps=(suf==='2')?2:1, sign=(suf==="'")?-1:+1;
    rotateWhole(axis,sign,reps,cb);
  }else{
    const a=moveToAction(letter,suf);
    const go=(left)=>{ if(left<=0){cb&&cb(); return;} rotate(a.axis,a.layer,a.sign, ()=>go(left-1)); };
    go(a.reps);
  }
}
labels.forEach(lbl=>{
  const b=document.createElement('button'); b.className='btn-key'; b.textContent=lbl; b.addEventListener('click', ()=>applyLabel(lbl)); moveGrid.appendChild(b);
});

/* ---------- Scramble (faces only) + enable Continue when done ---------- */
const SCR_FACES=['U','D','L','R','F','B'], SCR_SUFFIX=['',"'",'2'];
function genScramble(n=20){ const out=[]; let lastAxis=-1; while(out.length<n){ const f=SCR_FACES[(Math.random()*6)|0]; const axis=(f==='U'||f==='D')?0: (f==='L'||f==='R')?1:2; if(axis===lastAxis) continue; const s=SCR_SUFFIX[(Math.random()*3)|0]; out.push(f+s); lastAxis=axis; } return out; }
function playScramble(seq, onDone){
  let i=0; function next(){ if(i>=seq.length){ onDone&&onDone(); return; }
    const tok=seq[i++]; applyLabel(tok, next);
  } next();
}

const btnScramble = document.getElementById('btn-scramble');
function enableContinue(){
  const btnContinue = document.getElementById('btn-continue');
  const coachContinue = document.getElementById('coach-continue');
  if(!btnContinue.disabled) return;
  btnContinue.disabled = false;
  btnContinue.removeAttribute('aria-disabled');
  coachContinue.classList.remove('hidden');
  positionCoaches();
}
function serializeState(){
  return cubies.map(c=>({p:[c.position.x,c.position.y,c.position.z],q:[c.quaternion.x,c.quaternion.y,c.quaternion.z,c.quaternion.w]}));
}
btnScramble.addEventListener('click', ()=>{
  const seq = genScramble(20);
  playScramble(seq, ()=>{
    localStorage.setItem('erno_scramble_state_v1', JSON.stringify(serializeState()));
    enableContinue();
    revealOnce('coach-continue');
  });
});

// render loop
(function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();

/* ---------- Coach overlay placement ---------- */
const coachScramble = document.getElementById('coach-scramble');
const coachMoves = document.getElementById('coach-moves');
const coachContinue = document.getElementById('coach-continue');
const movePicker = document.getElementById('movePicker');
const btnContinue = document.getElementById('btn-continue');

function placeCoach(coachEl, targetEl, where){
  if(!coachEl || !targetEl) return;
  const r = targetEl.getBoundingClientRect();
  const pad = 8;
  let left = r.left + r.width/2;
  let top = r.top;
  if(where==='below'){
    coachEl.classList.remove('down','left','right'); coachEl.classList.add('up');
    top = r.bottom + 4;
    left = r.left + r.width/2;
    coachEl.style.transform = 'translate(-50%, 0)';
  }else if(where==='above'){
    coachEl.classList.remove('up','left','right'); coachEl.classList.add('down');
    top = r.top - coachEl.offsetHeight - pad;
    left = r.left + 16;
    coachEl.style.transform = 'translate(0, 0)';
  }else if(where==='right'){
    coachEl.classList.remove('up','down','right'); coachEl.classList.add('left');
    top = r.top + r.height/2 - coachEl.offsetHeight/2;
    left = r.right + pad;
    coachEl.style.transform = 'translate(0, 0)';
  }else{
    coachEl.classList.remove('up','down','left'); coachEl.classList.add('right');
    top = r.top + r.height/2 - coachEl.offsetHeight/2;
    left = r.left - coachEl.offsetWidth - pad;
    coachEl.style.transform = 'translate(0, 0)';
  }
  coachEl.style.top = `${Math.max(8, top)}px`;
  coachEl.style.left = `${Math.max(8, left)}px`;
}

function revealOnce(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.classList.remove('hidden');
  if(id==='coach-scramble'){
    const off=()=>{ el.classList.add('hidden'); btnScramble.removeEventListener('click',off); };
    btnScramble.addEventListener('click',off,{once:true});
  }
  if(id==='coach-moves'){
    const off=()=>{ el.classList.add('hidden'); movePicker.removeEventListener('click',off); };
    movePicker.addEventListener('click',off,{once:true});
  }
}

function positionCoaches(){
  if(!coachScramble.classList.contains('hidden')) placeCoach(coachScramble, btnScramble, 'below');
  if(!coachMoves.classList.contains('hidden')) placeCoach(coachMoves, movePicker, 'above');
  if(!coachContinue.classList.contains('hidden')) placeCoach(coachContinue, btnContinue, 'below');
}
window.addEventListener('resize', positionCoaches);
revealOnce('coach-scramble');
revealOnce('coach-moves');
setTimeout(positionCoaches, 0);

/* ---------- Continue button behavior ---------- */
btnContinue.addEventListener('click', ()=>{
  localStorage.setItem('erno_firststeps_leave_state_v1', JSON.stringify(serializeState()));
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Starting Daisy…';
  setTimeout(()=>{ location.href = 'adaptive-tutorial-daisy.html'; }, 300);
});
})();
</script>
</body>
</html>