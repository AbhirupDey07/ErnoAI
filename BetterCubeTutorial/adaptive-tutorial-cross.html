<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Erno AI ‚Äî Adaptive Tutorial ‚Ä¢ Cross</title>
<style>
:root{
  --bg:#0b0c10; --panel:#121420; --ink:#e8eefc; --muted:#92a0b8; --line:#1b2133; --splashA:#11182a;
  /* derived; populated by JS too */
  --card:#0d1222; --chip:#16213a; --chipBorder:#22325a;
  --btn:#16233e; --btnBorder:#22325a; --accent:#6ea8ff;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
#brand{position:fixed;left:50%;top:12px;transform:translateX(-50%);font-weight:800;font-size:18px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:.4rem .6rem;backdrop-filter:blur(2px);z-index:10}
#topbar{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10}
#topright{position:fixed;right:12px;top:12px;z-index:10}
button{background:var(--btn);border:1px solid var(--btnBorder);color:var(--ink);border-radius:10px;padding:.55rem .8rem;font-weight:800;cursor:pointer}
button:hover{filter:brightness(1.07)}
button:disabled{opacity:.55;filter:grayscale(.2);cursor:not-allowed}

#stage{position:absolute;inset:0}
canvas{display:block;width:100%;height:100%;touch-action:none}

/* Move Picker (theme-flexible, matches tutorial style) */
#movePicker{
  position:fixed;right:12px;bottom:12px;z-index:21;
  background:var(--card);color:var(--ink);border:1px solid var(--line);
  border-radius:12px;padding:8px;box-shadow:0 10px 24px rgba(0,0,0,.35);min-width:min(720px,92vw);backdrop-filter:blur(2px);
}
#movePicker h3{margin:0 0 6px 0;font-size:13px;font-weight:800}
#score{font-weight:800;margin-left:8px;opacity:.95}
.keygrid{display:flex;flex-wrap:wrap;gap:6px}
.btn-key{
  font-family:ui-monospace,Consolas,monospace;padding:.45rem .65rem;border-radius:10px;border:1px solid var(--btnBorder);
  background:var(--btn);color:var(--ink);font-weight:800;cursor:pointer;transition:filter .15s ease
}
.btn-key:hover{filter:brightness(1.07)}
.btn-key:focus{outline:2px solid #2f4fb3;outline-offset:1px}

/* Splash */
#splash{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 30%, var(--splashA) 0%, var(--bg) 60%);color:var(--ink);z-index:9999;transition:.4s}
#splash.hide{opacity:0;visibility:hidden}
#splash .inner{display:flex;flex-direction:column;align-items:center;gap:12px;text-align:center}
.spinner{width:36px;height:36px;border-radius:50%;border:3px solid rgba(255,255,255,.35);border-top-color:var(--ink);animation:spin .9s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* Themed confirm modal */
.modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.45);display:none; place-items:center; z-index:1000; backdrop-filter:blur(2px);}
.modal{
  width:min(520px,92vw); background:var(--panel); color:var(--ink);
  border:1px solid var(--line); border-radius:14px; padding:16px; box-shadow:0 16px 40px rgba(0,0,0,.45);
}
.modal h3{margin:0 0 6px 0; font-size:18px}
.modal p{margin:0 0 12px 0; color:var(--muted)}
.modal .row{display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap}
.modal .btn{background:var(--btn); border:1px solid var(--btnBorder); color:var(--ink); border-radius:10px; padding:.55rem .9rem; font-weight:800; cursor:pointer;}
.btn-ghost{background:transparent; border:1px solid var(--btnBorder); color:var(--ink);}
.modal-backdrop.show{display:grid}

/* Coach overlays */
.coach{
  position:fixed; z-index:2000; pointer-events:none; color:var(--ink);
  font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  display:flex; flex-direction:column; align-items:center;
}
.coach .caption{
  background:var(--panel);
  border:1px solid var(--btnBorder);
  color:var(--ink);
  padding:.30rem .55rem;
  border-radius:8px;
  font-weight:800;
  white-space:nowrap;
  text-wrap:balance;
  max-width:36ch;
}
.coach .arrow{width:0;height:0;margin:4px 0;border:9px solid transparent;animation:bob 1.2s ease-in-out infinite;opacity:.95}
.coach.down .arrow{border-top-color:var(--panel)}
.coach.up   .arrow{border-bottom-color:var(--panel)}
@keyframes bob{0%,100%{transform:translateY(0)}50%{transform:translateY(6px)}}
.hidden{display:none}

/* Intro popup */
#introBackdrop{position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); backdrop-filter:blur(2px); z-index:3000;}
#introBackdrop.show{display:grid}
#introCard{
  width:min(940px,94vw); max-height:90vh; overflow:auto;
  background:var(--panel); color:var(--ink);
  border:1px solid var(--line); border-radius:16px; box-shadow:0 24px 64px rgba(0,0,0,.5);
}
#introCard header{position:sticky; top:0; z-index:1; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px; background:var(--panel); border-bottom:1px solid var(--line);}
#introCard h2{margin:0; font-size:20px}
#introClose{background:transparent; border:1px solid var(--btnBorder); padding:.35rem .55rem; border-radius:10px; font-weight:800}
#introBody{padding:16px}
.intro-grid{display:grid; grid-template-columns: 1.1fr 1.4fr; gap:16px}
@media (max-width:900px){ .intro-grid{ grid-template-columns: 1fr } }
.intro-figure{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:10px; display:grid; place-items:center}
.intro-figure img{max-width:100%; height:auto; border-radius:10px}
.intro-copy p{margin:.2rem 0 .7rem 0; color:var(--ink)}
.intro-copy ul{margin:.2rem 0 .8rem 1.1rem; color:var(--muted)}
.intro-foot{position:sticky; bottom:0; background:var(--panel); border-top:1px solid var(--line); padding:12px 16px; display:flex; gap:10px; justify-content:flex-end; align-items:center}

/* Hint toast */
#hintToast{
  position:fixed; left:12px; bottom:12px; max-width:min(560px,92vw);
  background:var(--panel); color:var(--ink); border:1px solid var(--line);
  border-radius:12px; padding:10px 12px; box-shadow:0 12px 28px rgba(0,0,0,.4);
  z-index:2200; display:none;
}
#hintToast.show{ display:block; animation:hintIn .18s ease-out }
@keyframes hintIn{ from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:translateY(0)} }
#hintToast b{font-weight:800}
#hintToast .muted{color:var(--muted); font-weight:600; font-size:12px}
</style>
</head>
<body>
<div id="splash">
  <div class="inner">
    <h1>Erno AI<span style="display:block;opacity:.85;font-size:14px;margin-top:6px">Loading Cross‚Ä¶</span></h1>
    <div class="spinner" aria-hidden="true"></div>
  </div>
</div>

<div id="brand">Erno AI: Cross</div>
<div id="topbar">
  <button id="btn-restart" title="Reset to your saved Cross start">‚ü≤ Restart</button>
  <button id="btn-main">Main Page</button>
  <button id="btn-check">Check Cross</button>
  <button id="btn-hint" title="Suggest a next step">üí° Hint</button>
  <button id="btn-instructions" title="Open instructions">Instructions</button>
</div>
<div id="topright">
  <button id="btn-continue" disabled aria-disabled="true" title="Get 4/4 to continue">Continue ‚Üí</button>
</div>

<div id="stage"><canvas id="view"></canvas></div>

<div id="movePicker" role="group" aria-label="Move Picker">
  <h3>Move Picker <span id="score">(number of cross edges in place: 0/4)</span></h3>
  <div class="keygrid" id="moveGrid"></div>
</div>

<!-- Confirm modal -->
<div id="confirmWrap" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmDesc">
    <h3 id="confirmTitle">Leave this tutorial?</h3>
    <p id="confirmDesc">You'll lose unsaved progress if you leave. Are you sure?</p>
    <div class="row">
      <button id="confirmCancel" class="btn btn-ghost">Cancel</button>
      <button id="confirmOk" class="btn">OK</button>
    </div>
  </div>
</div>

<!-- Coaches -->
<div id="coach-check" class="coach up" role="note" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Use this to check your Cross progress</div>
</div>
<div id="coach-moves" class="coach down" role="note" aria-live="polite">
  <div class="caption">Use the <b>Move Picker</b> or drag faces to turn the cube</div>
  <div class="arrow" aria-hidden="true"></div>
</div>
<div id="coach-continue" class="coach up hidden" role="status" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Nice! Cross solved ‚Äî continue when ready</div>
</div>

<!-- Cross Intro (popup) -->
<div id="introBackdrop" role="dialog" aria-modal="true" aria-labelledby="introTitle" aria-describedby="introDesc">
  <div id="introCard">
    <header>
      <h2 id="introTitle">Step 2: The <span style="color:var(--accent)">White Cross</span></h2>
      <button id="introClose" title="Close">‚úï</button>
    </header>
    <div id="introBody">
      <div class="intro-grid">
        <figure class="intro-figure">
          <img src="https://images.squarespace-cdn.com/content/v1/54f2df67e4b079e94c291e4f/1427442870331-Q2HNC7FV2FW894P2KEBP/cross+done+u+cross.png" alt="Illustration of a solved white cross aligned with side centers."/>
        </figure>
        <div class="intro-copy" id="introDesc">
          <p><b>Goal:</b> Build a <b>white cross</b> on the white-center face <i>and</i> align each edge‚Äôs side color with its matching side-center. This organizes the cube so the first layer inserts cleanly.</p>
          <p><b>From Daisy ‚Üí Cross:</b></p>
          <ul>
            <li>For each white edge on U, <b>spin U</b> until the <i>side color</i> matches its side-center.</li>
            <li>Turn that face <code>F2</code> (a half-turn) to flip the edge down next to the white center.</li>
            <li>If an edge is flipped in the bottom layer, lift it out (e.g., <code>R U R'</code>), realign on U, then <code>F2</code>.</li>
          </ul>
          <p><b>Checker logic:</b> We verify four things: the white edge sits next to the white center, the white sticker faces the white face, and the edge‚Äôs side sticker matches the adjacent side-center color. When all <b>4/4</b> are correct, <b>Continue</b> unlocks.</p>
          <p style="color:var(--muted)">Tip: You can rotate the whole cube freely ‚Äî the checker reads true 3D geometry, not just what‚Äôs ‚Äúup‚Äù on screen.</p>
        </div>
      </div>
    </div>
    <div class="intro-foot"><button id="introStart">Got it ‚Äî Let‚Äôs build the cross</button></div>
  </div>
</div>

<!-- Hint toast -->
<div id="hintToast" aria-live="polite"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
/* ===== Theme system (same as Daisy) ===== */
const STORAGE_KEY='erno_theme_v1';
const THEMES = {
  default:{name:'Midnight (Default)',v:{bg:'#0b0c10',panel:'#121420',ink:'#e8eefc',muted:'#92a0b8',line:'#1b2133',splashA:'#11182a'}},
  cream:{name:'Cream',v:{bg:'#f4efe6',panel:'#fffaf2',ink:'#2c2a25',muted:'#6b665b',line:'#e1d9c9',splashA:'#efe7d8'}},
  caramel:{name:'Caramel',v:{bg:'#2a1f1a',panel:'#3b2b22',ink:'#f8e9d4',muted:'#d9c2a8',line:'#4c3a30',splashA:'#3a2a22'}},
  cyber:{name:'Cyber',v:{bg:'#0a0f0a',panel:'#0f1510',ink:'#d5ffd5',muted:'#90c990',line:'#183018',splashA:'#0f1c10'}},
  nord:{name:'Nord',v:{bg:'#2e3440',panel:'#3b4252',ink:'#eceff4',muted:'#c0c8d5',line:'#4c566a',splashA:'#323a49'}},
  dracula:{name:'Dracula',v:{bg:'#282a36',panel:'#1e2029',ink:'#f8f8f2',muted:'#b6b6c1',line:'#3b3e4b',splashA:'#2f3140'}},
  solarDark:{name:'Solarized Dark',v:{bg:'#002b36',panel:'#073642',ink:'#eee8d5',muted:'#93a1a1',line:'#0b3a46',splashA:'#03313c'}},
  solarLight:{name:'Solarized Light',v:{bg:'#fdf6e3',panel:'#f5efd9',ink:'#073642',muted:'#657b83',line:'#e6dec4',splashA:'#efe8d2'}},
  catMocha:{name:'Catppuccin Mocha',v:{bg:'#1e1e2e',panel:'#242437',ink:'#cdd6f4',muted:'#a6adc8',line:'#313244',splashA:'#23233a'}},
  gruvDark:{name:'Gruvbox Dark',v:{bg:'#1d2021',panel:'#282828',ink:'#ebdbb2',muted:'#d5c4a1',line:'#3c3836',splashA:'#232524'}},
  gruvLight:{name:'Gruvbox Light',v:{bg:'#fbf1c7',panel:'#f2e5bc',ink:'#3c3836',muted:'#7c6f64',line:'#e0d2a4',splashA:'#f5e8bf'}},
  oneDark:{name:'One Dark',v:{bg:'#21252b',panel:'#282c34',ink:'#e6efff',muted:'#a0afc1',line:'#323844',splashA:'#252a31'}},
  synthwave:{name:'Synthwave',v:{bg:'#1b1227',panel:'#231833',ink:'#fedaff',muted:'#d7b6ff',line:'#3a2857',splashA:'#23173a'}},
  monokai:{name:'Monokai',v:{bg:'#272822',panel:'#2e2f27',ink:'#f8f8f2',muted:'#c2c2b4',line:'#3b3c34',splashA:'#2c2d26'}},
  mint:{name:'Mint',v:{bg:'#0e1412',panel:'#111a16',ink:'#d9fff2',muted:'#9de5cf',line:'#173026',splashA:'#15231e'}},
  rosePine:{name:'Ros√© Pine',v:{bg:'#191724',panel:'#1f1d2e',ink:'#e0def4',muted:'#908caa',line:'#2a2837',splashA:'#201e2f'}},
  highContrast:{name:'High Contrast',v:{bg:'#000000',panel:'#0a0a0a',ink:'#ffffff',muted:'#bfbfbf',line:'#222222',splashA:'#101010'}},
  mono:{name:'Monochrome',v:{bg:'#111114',panel:'#16171a',ink:'#f1f2f5',muted:'#a9acb3',line:'#272a33',splashA:'#1b1c20'}}
};
function hexToRgb(h){ h=h.replace('#',''); if(h.length===3) h=h.split('').map(c=>c+c).join(''); const n=parseInt(h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
function rgbToHex({r,g,b}){ const n=(r<<16)|(g<<8)|b; return '#'+n.toString(16).padStart(6,'0'); }
function mix(a,b,t){ const A=hexToRgb(a),B=hexToRgb(b); return rgbToHex({r:Math.round(A.r+(B.r-A.r)*t),g:Math.round(A.g+(B.g-A.g)*t),b:Math.round(A.b+(B.b-A.b)*t)}); }
function applyThemeVars(v){
  const rs=document.documentElement.style;
  const card = mix(v.panel, v.bg, 0.15);
  const chip = mix(v.panel, v.line, 0.35);
  const chipBorder = mix(v.line, v.panel, 0.4);
  const btn = mix(v.panel, v.line, 0.25);
  const btnBorder = mix(v.line, v.panel, 0.25);
  const splashA = v.splashA || v.panel;
  const accent = mix(v.ink, v.panel, 0.2);
  rs.setProperty('--bg', v.bg);
  rs.setProperty('--panel', v.panel);
  rs.setProperty('--ink', v.ink);
  rs.setProperty('--muted', v.muted);
  rs.setProperty('--line', v.line);
  rs.setProperty('--splashA', splashA);
  rs.setProperty('--card', card);
  rs.setProperty('--chip', chip);
  rs.setProperty('--chipBorder', chipBorder);
  rs.setProperty('--btn', btn);
  rs.setProperty('--btnBorder', btnBorder);
  rs.setProperty('--accent', accent);
}
function applyThemeById(id){ const t = THEMES[id] || THEMES.default; applyThemeVars(t.v); }
applyThemeById(localStorage.getItem(STORAGE_KEY) || 'default');
window.addEventListener('storage', (e)=>{ if(e.key===STORAGE_KEY) applyThemeById(e.newValue || 'default'); });

const splash=document.getElementById('splash');
function hideSplash(){ splash.classList.add('hide'); setTimeout(()=>splash.remove(),800); }
window.addEventListener('load', ()=> setTimeout(hideSplash, 400));

/* ===== Modal for Main ===== */
const modal = document.getElementById('confirmWrap');
const okBtn = document.getElementById('confirmOk');
const cancelBtn = document.getElementById('confirmCancel');
function openConfirm(){ modal.classList.add('show'); modal.setAttribute('aria-hidden','false'); okBtn.focus(); }
function closeConfirm(){ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
modal.addEventListener('click', (e)=>{ if(e.target === modal) closeConfirm(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.classList.contains('show')) closeConfirm(); });
okBtn.addEventListener('click', ()=>{
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Returning to Main Page‚Ä¶';
  modal.classList.remove('show');
  setTimeout(()=>{ location.href = 'adaptive-move-picker.html'; }, 300);
});
cancelBtn.addEventListener('click', closeConfirm);

/* ===== Scene (Adaptive engine cloned from Daisy) ===== */
const canvas = document.getElementById('view');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50,1,.1,1000);
const CAM_INIT_POS = new THREE.Vector3(5.2, 4.7, 6.1);
const CAM_INIT_TARGET = new THREE.Vector3(0, 0, 0);
function resetView(){ camera.up.set(0,1,0); camera.position.copy(CAM_INIT_POS); camera.lookAt(CAM_INIT_TARGET); }
resetView();
scene.add(camera);
scene.add(new THREE.AmbientLight(0xffffff,.6));
const key = new THREE.DirectionalLight(0xffffff,.9); key.position.set(3,6,7); scene.add(key);
const stage = document.getElementById('stage');
new ResizeObserver(()=>{ const w=stage.clientWidth,h=stage.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();}).observe(stage);

/* Background grid panes */
;(function(size=600,div=120,color=0x223355,opacity=0.07){
  const mk=()=>{const gh=new THREE.GridHelper(size,div,color,color);gh.material.transparent=true;gh.material.opacity=opacity;return gh};
  const g=new THREE.Group(), xz1=mk(), xz2=mk(), xy1=mk(), xy2=mk(), yz1=mk(), yz2=mk();
  xz1.position.y=size/2; xz2.position.y=-size/2;
  xy1.rotation.x=Math.PI/2; xy1.position.z=size/2; xy2.rotation.x=Math.PI/2; xy2.position.z=-size/2;
  yz1.rotation.z=Math.PI/2; yz1.position.x=size/2; yz2.rotation.z=Math.PI/2; yz2.position.x=-size/2;
  g.add(xz1,xz2,xy1,xy2,yz1,yz2); scene.add(g);
})();

/* Build cubies (stickers with local normals) */
const cubeGroup = new THREE.Group(); scene.add(cubeGroup);
let cubies=[]; const CELL=1, STICKER=.92, GAP=.04;
const COLORS={ U:0xffd500, D:0xffffff, L:0xcc0000, R:0xff8c1a, F:0x00a040, B:0x0040cc };
function mkCubie(i,j,k){
  const core = new THREE.Mesh(new THREE.BoxGeometry(STICKER,STICKER,STICKER), new THREE.MeshStandardMaterial({color:0x111317,roughness:.9}));
  const g=new THREE.Group(); g.add(core); g.position.set(i*CELL,j*CELL,k*CELL);
  const faces=[
    {key:'R',show:i=== 1,n:new THREE.Vector3( 1,0,0)},
    {key:'L',show:i===-1,n:new THREE.Vector3(-1,0,0)},
    {key:'U',show:j=== 1,n:new THREE.Vector3( 0,1,0)},
    {key:'D',show:j===-1,n:new THREE.Vector3( 0,-1,0)},
    {key:'F',show:k=== 1,n:new THREE.Vector3( 0,0,1)},
    {key:'B',show:k===-1,n:new THREE.Vector3( 0,0,-1)}
  ];
  const pg=new THREE.PlaneGeometry(STICKER-GAP,STICKER-GAP);
  faces.forEach(f=>{
    if(!f.show) return;
    const s=new THREE.Mesh(pg,new THREE.MeshBasicMaterial({color:COLORS[f.key]}));
    s.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), f.n);
    s.position.copy(f.n).multiplyScalar(STICKER/2+0.001);
    s.userData = { isSticker:true, faceKey:f.key, localNormal:f.n.clone() };
    g.add(s);
  });
  cubeGroup.add(g); cubies.push(g);
}
(function build(){ for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) for(let k=-1;k<=1;k++) mkCubie(i,j,k); })();

/* Orbit (RMB or Shift+LMB) */
let orbit=false, px=0, py=0;
canvas.addEventListener('contextmenu',e=>e.preventDefault(), {passive:false});
canvas.addEventListener('pointerdown',e=>{
  if(e.pointerType!=='mouse') return;
  if(e.button===2||(e.button===0&&e.shiftKey)){ orbit=true; px=e.clientX; py=e.clientY; }
},{passive:false});
canvas.addEventListener('pointerup',()=>{orbit=false;},{passive:false});
canvas.addEventListener('pointerleave',()=>{orbit=false;},{passive:false});
function orbitStep(dx,dy){
  const sp=0.005, target=CAM_INIT_TARGET.clone();
  const f=new THREE.Vector3(); camera.getWorldDirection(f);
  const worldUp=new THREE.Vector3(0,1,0);
  const qYaw=new THREE.Quaternion().setFromAxisAngle(worldUp, -dx*sp);
  const rightV=new THREE.Vector3().crossVectors(f,camera.up).normalize();
  const safeRight= rightV.lengthSq()>1e-8 ? rightV : new THREE.Vector3(1,0,0);
  const qPitch=new THREE.Quaternion().setFromAxisAngle(safeRight, -dy*sp);
  const q=new THREE.Quaternion().multiply(qYaw).multiply(qPitch);
  const off=camera.position.clone().sub(target).applyQuaternion(q);
  camera.up.applyQuaternion(q);
  camera.position.copy(target.add(off));
  camera.lookAt(CAM_INIT_TARGET);
}
canvas.addEventListener('pointermove',e=>{
  if(!orbit) return;
  const dx=e.clientX-px, dy=e.clientY-py; px=e.clientX; py=e.clientY;
  orbitStep(dx,dy); renderer.render(scene,camera);
},{passive:false});
window.addEventListener('wheel',e=>{ camera.position.multiplyScalar(1+Math.sign(e.deltaY)*.08).clampLength(4,40); },{passive:true});

/* Camera basis */
function camBasis(){ const f=new THREE.Vector3(); camera.getWorldDirection(f).normalize(); const r=new THREE.Vector3().crossVectors(f,camera.up).normalize(); const u=new THREE.Vector3().crossVectors(r,f).normalize(); return {f,r,u}; }

/* Turn engine (Adaptive) */
const AX={x:new THREE.Vector3(1,0,0), y:new THREE.Vector3(0,1,0), z:new THREE.Vector3(0,0,1)};
let turning=false;
function animateTo(pivot, axisVec, start, target, sel, done){
  turning=true;
  const dur=160, t0=performance.now();
  const tick=t=>{
    const k=Math.min(1,(t-t0)/dur), ang=start+(target-start)*k;
    pivot.setRotationFromAxisAngle(axisVec,ang);
    renderer.render(scene,camera);
    if(k<1) requestAnimationFrame(tick);
    else{
      pivot.updateMatrixWorld(true);
      for(const c of sel){ cubeGroup.attach(c); c.position.set(Math.round(c.position.x),Math.round(c.position.y),Math.round(c.position.z)); }
      cubeGroup.remove(pivot); turning=false; done&&done();
    }
  };
  requestAnimationFrame(tick);
}
function select(axis,layer){ const out=[]; for(const c of cubies){ const v=axis==='x'?c.position.x:axis==='y'?c.position.y:c.position.z; if(Math.round(v)===layer) out.push(c);} return out; }
function rotate(axis,layer,sign,cb){ if(turning) return; const sel=select(axis,layer); const pivot=new THREE.Group(); cubeGroup.add(pivot); sel.forEach(c=>pivot.attach(c)); animateTo(pivot,AX[axis],0,sign*(Math.PI/2),sel,cb); }

function rotateWhole(axis,sign,reps,cb){
  if(turning) return;
  const dur=160, quarter=sign*(Math.PI/2);
  const step=(left)=>{
    if(left<=0){ cb&&cb(); return; }
    turning=true;
    const startQ=cubeGroup.quaternion.clone();
    const targetQ=new THREE.Quaternion().setFromAxisAngle(AX[axis], quarter);
    const t0=performance.now();
    const tick=t=>{
      const k=Math.min(1,(t-t0)/dur);
      const qStep=new THREE.Quaternion().setFromAxisAngle(AX[axis], quarter*k);
      cubeGroup.quaternion.copy(startQ.clone().multiply(qStep));
      renderer.render(scene,camera);
      if(k<1) requestAnimationFrame(tick);
      else { cubeGroup.quaternion.copy(startQ.clone().multiply(targetQ)); turning=false; step(left-1); }
    };
    requestAnimationFrame(tick);
  };
  step(reps||1);
}

/* Drag-to-turn (cube-local), with Shift-lock */
const ray=new THREE.Raycaster(), ndc=new THREE.Vector2();
const toNDC=e=>{ const r=canvas.getBoundingClientRect(); ndc.x=((e.clientX-r.left)/r.width)*2-1; ndc.y=-((e.clientY-r.top)/r.height)*2+1; };
function pick(e){
  toNDC(e); ray.setFromCamera(ndc,camera);
  const hit=ray.intersectObjects(cubeGroup.children,true)[0];
  if(!hit) return null;
  let root=hit.object; while(root && root.parent!==cubeGroup) root=root.parent;
  const n=hit.face?hit.face.normal.clone().transformDirection(hit.object.matrixWorld):new THREE.Vector3(0,0,1).applyQuaternion(hit.object.getWorldQuaternion(new THREE.Quaternion()));
  return {cubie:root,normal:n.normalize()};
}
const AXV={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};
const drag={active:false,sx:0,sy:0,axis:null,layer:0,sel:[],pivot:null,plus:null,angle:0};
function resetDrag(){ drag.active=false; drag.axis=null; drag.layer=0; drag.sel=[]; drag.pivot=null; drag.plus=null; drag.angle=0; }
const AXIS_LOCK_FACE=36, AXIS_LOCK_SLICE=9, SNAP_FRAC_FACE=.10, SNAP_FRAC_SLICE=.08, HALF=.75;

let shiftLock=false;
function cancelDragSnapBack(){
  if(!drag.active) return;
  if(drag.pivot){
    animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag());
  }else{
    resetDrag();
  }
}
window.addEventListener('keydown', (e)=>{ if(e.key==='Shift'){ if(!shiftLock){ shiftLock=true; cancelDragSnapBack(); } }});
window.addEventListener('keyup', (e)=>{ if(e.key==='Shift'){ shiftLock=false; } });

canvas.addEventListener('pointerdown',e=>{
  if(e.pointerType==='mouse' && e.button!==0) return;
  if(shiftLock || e.shiftKey) return;
  if(turning) return;
  const info=pick(e); if(!info) return;
  drag.active=true; drag.sx=e.clientX; drag.sy=e.clientY; drag.axis=null; drag.hit=info;
});
canvas.addEventListener('pointermove',e=>{
  if(shiftLock){ cancelDragSnapBack(); return; }
  if(!drag.active||turning) return;
  const dx=e.clientX-drag.sx, dy=e.clientY-drag.sy, d2=dx*dx+dy*dy;

  const invQ=cubeGroup.getWorldQuaternion(new THREE.Quaternion()).invert();
  const n=drag.hit.normal.clone().applyQuaternion(invQ);

  if(!drag.axis){
    const cand=Math.abs(n.x)>0.8?['y','z']:Math.abs(n.y)>0.8?['x','z']:['x','y'];
    const {r,u}=camBasis();
    const dragWorld=new THREE.Vector3().addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
    const dragLocal=dragWorld.applyQuaternion(invQ).normalize();
    let axis=cand[0], best=-1;
    for(const a of cand){ const s=Math.abs(dragLocal.dot(AXV[a])); if(s>best){best=s; axis=a;} }
    const info2=pick(e); if(!info2) return;
    const layerGuess=Math.max(-1,Math.min(1),Math.round(axis==='x'?info2.cubie.position.x:axis==='y'?info2.cubie.position.y:axis==='z'?info2.cubie.position.z:0));
  }

  if(!drag.axis){
    if(d2 < (drag.layer===0?AXIS_LOCK_SLICE:AXIS_LOCK_FACE)) return;
    drag.axis = Math.abs(n.x)>0.8? (Math.abs(n.y)>0.8? 'z' : 'y') : 'x';
    const info2=pick(e); if(!info2) return;
    drag.layer = Math.max(-1,Math.min(1,Math.round(drag.axis==='x'?info2.cubie.position.x:drag.axis==='y'?info2.cubie.position.y:info2.cubie.position.z)));
    drag.sel=select(drag.axis,drag.layer);
    drag.pivot=new THREE.Group(); cubeGroup.add(drag.pivot); drag.sel.forEach(cu=>drag.pivot.attach(cu));
    drag.plus=new THREE.Vector3().crossVectors(n,AXV[drag.axis]).normalize();
  }

  const {r,u}=camBasis();
  const dragWorld=new THREE.Vector3().addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
  const invQ2=cubeGroup.getWorldQuaternion(new THREE.Quaternion()).invert();
  const dragLocal=dragWorld.applyQuaternion(invQ2).normalize();
  const s=dragLocal.dot(drag.plus);
  drag.angle=THREE.MathUtils.clamp(s*Math.PI,-3.2,3.2);
  drag.pivot.setRotationFromAxisAngle(AXV[drag.axis], drag.angle);
  renderer.render(scene,camera);
});
function commitOrCancel(){
  if(!drag.axis || !drag.pivot){ resetDrag(); return; }
  const q=Math.PI/2, a=Math.abs(drag.angle);
  const frac=(drag.layer===0?SNAP_FRAC_SLICE:SNAP_FRAC_FACE);
  if(a<q*frac){ animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag()); }
  else{
    let reps, sign;
    if(a>=Math.PI*HALF){ reps=2; sign=(drag.angle>0)?+1:-1; } else { reps=1; sign=(drag.angle>0)?+1:-1; }
    const go=(left)=>{ if(left<=0){ resetDrag(); return; } animateTo(drag.pivot, AXV[drag.axis], left===reps?drag.angle:0, sign*(Math.PI/2), drag.sel, ()=>go(left-1)); };
    go(reps);
  }
}
window.addEventListener('pointerup',()=>{ if(shiftLock){ cancelDragSnapBack(); return; } if(drag.active) commitOrCancel(); });
canvas.addEventListener('pointercancel',()=>{ if(shiftLock){ cancelDragSnapBack(); return; } if(drag.active) commitOrCancel(); });

/* Adaptive mapping + Move Picker (same labels as Daisy) */
function majorAxis(v){ const ax=Math.abs(v.x), ay=Math.abs(v.y), az=Math.abs(v.z);
  if(ax>=ay&&ax>=az) return {axis:'x',sgn:v.x>=0?+1:-1};
  if(ay>=ax&&ay>=az) return {axis:'y',sgn:v.y>=0?+1:-1};
  return {axis:'z',sgn:v.z>=0?+1:-1}; }
function viewMapping(){
  const {f,r,u}=camBasis();
  const invQ=cubeGroup.getWorldQuaternion(new THREE.Quaternion()).invert();
  const rL=r.clone().applyQuaternion(invQ), uL=u.clone().applyQuaternion(invQ), fL=new THREE.Vector3(-f.x,-f.y,-f.z).applyQuaternion(invQ);
  const Rm=majorAxis(rL), Um=majorAxis(uL), Fm=majorAxis(fL);
  const map={
    R:{axis:Rm.axis, layer:Rm.sgn>0?+1:-1, sgn:Rm.sgn}, L:{axis:Rm.axis, layer:Rm.sgn>0?-1:+1, sgn:-Rm.sgn},
    U:{axis:Um.axis, layer:Um.sgn>0?+1:-1, sgn:Um.sgn}, D:{axis:Um.axis, layer:Um.sgn>0?-1:+1, sgn:-Um.sgn},
    F:{axis:Fm.axis, layer:Fm.sgn>0?+1:-1, sgn:Fm.sgn}, B:{axis:Fm.axis, layer:Fm.sgn>0?-1:+1, sgn:-Fm.sgn}
  };
  map.M={axis:map.R.axis, layer:0, sgn:map.L.sgn};
  map.E={axis:map.U.axis, layer:0, sgn:map.D.sgn};
  map.S={axis:map.F.axis, layer:0, sgn:map.F.sgn};
  return map;
}
function moveToAction(letter,suffix){
  const M=viewMapping()[letter];
  let reps=1, cw=true;
  if(suffix==="2"){ reps=2; cw=true; }
  else if(suffix==="'"){ cw=false; }
  if(letter==='E'||letter==='S'||letter==='M') cw=!cw;
  const isSlice=(letter==='M'||letter==='E'||letter==='S');
  const sign=isSlice ? (cw?+M.sgn:-M.sgn) : (cw?-M.sgn:+M.sgn);
  return {axis:M.axis, layer:M.layer, sign, reps};
}
const labels=["R","R'","U","U'","F","F'","L","L'","D","D'","B","B'","M","M'","E","E'","S","S'"]; // EXACTLY like Daisy
const moveGrid=document.getElementById('moveGrid');
function applyLabel(lbl,cb){
  if(turning) return;
  const m=/^([RULDFBMESxyz])([2']?)$/.exec(lbl); if(!m) return;
  const letter=m[1], suf=m[2]||'';
  if('xyz'.includes(letter)){
    const axis=letter, reps=(suf==='2')?2:1, sign=(suf==="'")?+1:-1;
    rotateWhole(axis,sign,reps,cb);
  }else{
    const a=moveToAction(letter,suf);
    const go=(left)=>{ if(left<=0){cb&&cb(); return;} rotate(a.axis,a.layer,a.sign, ()=>go(left-1)); }; go(a.reps);
  }
}
labels.forEach(lbl=>{ const b=document.createElement('button'); b.className='btn-key'; b.textContent=lbl; b.addEventListener('click',()=>applyLabel(lbl)); moveGrid.appendChild(b); });

/* ===== State I/O (carry from Daisy) ===== */
function serializeState(){ return cubies.map(c=>({ p:[c.position.x,c.position.y,c.position.z], q:[c.quaternion.x,c.quaternion.y,c.quaternion.z,c.quaternion.w] })); }
function applyState(state){
  if(!state || state.length!==cubies.length) return false;
  for(let i=0;i<cubies.length;i++){
    const it=state[i], c=cubies[i];
    c.position.set(Math.round(it.p[0]), Math.round(it.p[1]), Math.round(it.p[2]));
    c.quaternion.set(it.q[0],it.q[1],it.q[2],it.q[3]);
    c.updateMatrixWorld(true);
  }
  return true;
}
function loadJSON(key){ try{ return JSON.parse(localStorage.getItem(key)||''); }catch(_){ return null; } }

const carry = loadJSON('erno_cross_entry_state_v1') || null;
if(carry && carry.cubies && carry.cubeQ){
  cubeGroup.quaternion.set(carry.cubeQ[0],carry.cubeQ[1],carry.cubeQ[2],carry.cubeQ[3]);
  applyState(carry.cubies);
} else {
  // Fallback to Daisy's saved states if user refreshed directly on this page
  const fallback = loadJSON('erno_firststeps_leave_state_v1') || loadJSON('erno_scramble_state_v1');
  if(fallback) applyState(fallback);
}

// Record initial for Restart
const initialCrossState = serializeState();
const initialCubeQ = [cubeGroup.quaternion.x,cubeGroup.quaternion.y,cubeGroup.quaternion.z,cubeGroup.quaternion.w];

/* ===== Cross check (robust, orientation-agnostic) + matches ===== */
const WHITE = 0xffffff;
function findCubieAt(x,y,z){ for(const c of cubies){ if(Math.round(c.position.x)===x && Math.round(c.position.y)===y && Math.round(c.position.z)===z) return c;} return null; }
function worldPos(obj){ return obj.getWorldPosition(new THREE.Vector3()); }
function stickerFacingDir(cubie, dir, tol=0.8){
  const q = cubie.getWorldQuaternion(new THREE.Quaternion());
  let best=null, bestDot=tol;
  for(const ch of cubie.children){
    if(!ch.userData?.isSticker) continue;
    const n = ch.userData.localNormal.clone().applyQuaternion(q).normalize();
    const d = n.dot(dir);
    if(d>bestDot){ best=ch; bestDot=d; }
  }
  return best; // may be null
}
function countCross(){
  const centerD = findCubieAt(0,-1,0);
  if(!centerD) return 0;
  const dPos = worldPos(centerD);
  const dOut = dPos.clone().normalize();

  const targets=[
    {edge:[ 1,-1, 0], side:[ 1, 0, 0]}, // R-D edge
    {edge:[-1,-1, 0], side:[-1, 0, 0]}, // L-D edge
    {edge:[ 0,-1, 1], side:[ 0, 0, 1]}, // F-D edge
    {edge:[ 0,-1,-1], side:[ 0, 0,-1]}, // B-D edge
  ];

  let good=0;
  for(const t of targets){
    const e = findCubieAt(t.edge[0],t.edge[1],t.edge[2]);
    const cSide = findCubieAt(t.side[0],t.side[1],t.side[2]);
    if(!e || !cSide) continue;
    const sPos = worldPos(cSide);
    const sOut = sPos.clone().normalize();

    const edgeTowardWhite = stickerFacingDir(e, dOut);
    if(!edgeTowardWhite || edgeTowardWhite.material.color.getHex() !== WHITE) continue;

    const edgeTowardSide = stickerFacingDir(e, sOut);
    const sideFaceOnCenter = stickerFacingDir(cSide, sOut);
    if(!edgeTowardSide || !sideFaceOnCenter) continue;
    if(edgeTowardSide.material.color.getHex() === sideFaceOnCenter.material.color.getHex()) good++;
  }
  return good;
}
function getCrossMatches(){
  const centerD = findCubieAt(0,-1,0);
  if(!centerD) return [];
  const dOut = worldPos(centerD).normalize();

  const targets=[
    {edge:[ 1,-1, 0], side:[ 1, 0, 0]}, // R-D edge
    {edge:[-1,-1, 0], side:[-1, 0, 0]}, // L-D edge
    {edge:[ 0,-1, 1], side:[ 0, 0, 1]}, // F-D edge
    {edge:[ 0,-1,-1], side:[ 0, 0,-1]}, // B-D edge
  ];
  const matches=[];
  for(const t of targets){
    const e=findCubieAt(t.edge[0],t.edge[1],t.edge[2]);
    const cSide=findCubieAt(t.side[0],t.side[1],t.side[2]);
    if(!e || !cSide) continue;
    const sOut = worldPos(cSide).normalize();
    const edgeTowardWhite = stickerFacingDir(e, dOut);
    const edgeTowardSide = stickerFacingDir(e, sOut);
    const sideFaceOnCenter = stickerFacingDir(cSide, sOut);
    if(!edgeTowardWhite || !edgeTowardSide || !sideFaceOnCenter) continue;
    if(edgeTowardWhite.material.color.getHex()===WHITE &&
       edgeTowardSide.material.color.getHex()===sideFaceOnCenter.material.color.getHex()){
      matches.push({edge:e, whiteSticker:edgeTowardWhite, sideSticker:edgeTowardSide});
    }
  }
  return matches;
}

/* ===== Glow/highlight (brighter + outside ring) ===== */
// tuneables
const GLOW_SCALE  = 1.55;   // bigger than sticker so it sits outside
const GLOW_OFFSET = 0.14;   // push further off the face (meters in your scene)
const GLOW_MS     = 2200;   // duration

let ringTexture=null;
function getRingTexture(){
  if(ringTexture) return ringTexture;
  const c=document.createElement('canvas'); c.width=c.height=256;
  const g=c.getContext('2d');
  // "ring" gradient: transparent center -> bright ring -> soft falloff
  const r=128;
  const grd=g.createRadialGradient(128,128, r*0.40, 128,128, r*0.98);
  grd.addColorStop(0.00, 'rgba(255,255,0,0)');      // clear center
  grd.addColorStop(0.45, 'rgba(255,255,0,0)');      // still clear
  grd.addColorStop(0.55, 'rgba(255,255,140,0.95)'); // bright ring
  grd.addColorStop(0.72, 'rgba(255,255,80,0.55)');  // halo
  grd.addColorStop(1.00, 'rgba(255,255,0,0)');      // fade out
  g.fillStyle=grd; g.fillRect(0,0,256,256);
  ringTexture=new THREE.CanvasTexture(c);
  ringTexture.needsUpdate=true;
  return ringTexture;
}

function flashSticker(sticker, ms=GLOW_MS){
  const tex=getRingTexture();
  const mat=new THREE.SpriteMaterial({
    map:tex, transparent:true,
    depthWrite:false, depthTest:false,   // always visible
    blending:THREE.AdditiveBlending,
    opacity:0
  });
  const spr=new THREE.Sprite(mat);
  const nLocal=sticker.userData?.localNormal?.clone()||new THREE.Vector3(0,0,1);

  // sit OUTSIDE the edge + be larger than the sticker
  spr.scale.set(GLOW_SCALE, GLOW_SCALE, GLOW_SCALE);
  spr.position.copy(nLocal.clone().multiplyScalar(GLOW_OFFSET));
  sticker.add(spr);

  const t0=performance.now();
  (function tick(t){
    const k=(t-t0)/ms;
    if(k>=1){ sticker.remove(spr); mat.dispose(); return; }
    // brighter pulse + a tiny size wobble
    const osc = 0.5+0.5*Math.sin((t-t0)/120);
    mat.opacity = 0.55 + 0.40*osc;                 // ‚¨ÖÔ∏è brightness
    const wobble = 1 + 0.08*osc;
    spr.scale.set(GLOW_SCALE*wobble, GLOW_SCALE*wobble, GLOW_SCALE*wobble);
    requestAnimationFrame(tick);
  })(t0);
}

function flashSolvedEdges(){
  const m=getCrossMatches();
  for(const it of m){
    flashSticker(it.whiteSticker);
    flashSticker(it.sideSticker);
  }
}


/* ===== Hint system (color-based, orientation-agnostic) ===== */
const COLOR_NAMES = {
  [COLORS.L]:'RED', [COLORS.R]:'ORANGE', [COLORS.F]:'GREEN', [COLORS.B]:'BLUE',
  [WHITE]:'WHITE', [COLORS.U]:'YELLOW'
};
function stickerWorldNormal(sticker){
  const q = sticker.parent.getWorldQuaternion(new THREE.Quaternion());
  return sticker.userData.localNormal.clone().applyQuaternion(q).normalize();
}
function faceOutVector(cubie){ return worldPos(cubie).normalize(); }

function findEdgeByColors(colorA, colorB){
  for(const c of cubies){
    let colors=[];
    for(const ch of c.children){
      if(ch.userData?.isSticker) colors.push(ch.material.color.getHex());
    }
    if(colors.length===2){
      if(colors.includes(colorA) && colors.includes(colorB)) return c;
    }
  }
  return null;
}
function firstUnsovledEdgeInfo(){
  const centerD = findCubieAt(0,-1,0);
  if(!centerD) return null;
  const dOut = faceOutVector(centerD);

  const sides = [
    {pos:[ 1,0,0], name:'ORANGE', hex:COLORS.R},
    {pos:[-1,0,0], name:'RED',    hex:COLORS.L},
    {pos:[ 0,0,1], name:'GREEN',  hex:COLORS.F},
    {pos:[ 0,0,-1],name:'BLUE',   hex:COLORS.B},
  ];

  // vectors for side directions to help classify
  const sideDirs = sides.map(s => ({...s, out: faceOutVector(findCubieAt(s.pos[0],s.pos[1],s.pos[2]))}));

  // Skip solved targets; pick first unsolved by side order above
  for(const s of sideDirs){
    const targetEdgeAtBottom = findCubieAt(s.pos[0], -1, s.pos[2]);
    if(targetEdgeAtBottom){
      const towardWhite = stickerFacingDir(targetEdgeAtBottom, dOut);
      const towardSide  = stickerFacingDir(targetEdgeAtBottom, s.out);
      const sideCenterSticker = stickerFacingDir(findCubieAt(s.pos[0],s.pos[1],s.pos[2]), s.out);
      if(towardWhite && towardSide && sideCenterSticker &&
         towardWhite.material.color.getHex()===WHITE &&
         towardSide.material.color.getHex()===sideCenterSticker.material.color.getHex()){
        // solved ‚Äî skip
        continue;
      }
    }
    // Find the edge cubie (anywhere) that has WHITE + s.hex
    const edge = findEdgeByColors(WHITE, s.hex);
    if(!edge) continue;

    // Find its WHITE sticker + side sticker objects
    let whiteSticker=null, otherSticker=null;
    for(const ch of edge.children){
      if(!ch.userData?.isSticker) continue;
      const h=ch.material.color.getHex();
      if(h===WHITE) whiteSticker=ch;
      else if(h===s.hex) otherSticker=ch;
    }
    if(!whiteSticker || !otherSticker) continue;

    const nWhite = stickerWorldNormal(whiteSticker);
    const dotD = nWhite.dot(dOut);
    const dotU = nWhite.dot(dOut.clone().multiplyScalar(-1));

    // Compare against each side direction to see if white faces a side
    let sideFacing=null, best=0.8;
    for(const sd of sideDirs){
      const d = nWhite.dot(sd.out);
      if(d>best){ best=d; sideFacing=sd; }
    }

    let message='';
    if(dotU>0.8){
      // white on U
      message = `Target <b>WHITE‚Äì${s.name}</b> is on <b>top</b>. Spin the top layer until the <b>${s.name}</b> sticker lines up with the <b>${s.name}</b> center, then turn the <b>${s.name}</b>-center face <b>180¬∞</b> to drop it next to WHITE.`;
    }else if(dotD>0.8){
      // white on D but wrong
      message = `Target <b>WHITE‚Äì${s.name}</b> is in the <b>bottom</b> but misaligned/flipped. Do a quick lift (e.g., a quarter turn on the <b>${s.name}</b>-center face) to bring it to top, align ${s.name} with its center, then turn the <b>${s.name}</b>-center face <b>180¬∞</b>.`;
    }else if(sideFacing){
      // white points to a side
      message = `Target <b>WHITE‚Äì${s.name}</b> is in the <b>middle layer</b> with WHITE facing <b>${sideFacing.name}</b>. Turn the <b>${sideFacing.name}</b>-center face to move WHITE to the top, then align ${s.name} with its center on top and turn the <b>${s.name}</b>-center face <b>180¬∞</b>.`;
    }else{
      // fallback generic
      message = `Target <b>WHITE‚Äì${s.name}</b> is off the cross. Bring WHITE to the top with a nearby face turn, align ${s.name} with its center on top, then turn the <b>${s.name}</b>-center face <b>180¬∞</b>.`;
    }

    return {message, edge, whiteSticker, otherSticker};
  }
  return null;
}
const hintToast = document.getElementById('hintToast');
let hintTimer=null;
function showHint(msg){
  hintToast.innerHTML = `<div>${msg}</div><div class="muted" style="margin-top:6px">Tip: the glow marks the piece I‚Äôm talking about.</div>`;
  hintToast.classList.add('show');
  clearTimeout(hintTimer);
  hintTimer=setTimeout(()=>hintToast.classList.remove('show'), 6500);
}

/* ===== UI wiring ===== */
const btnRestart = document.getElementById('btn-restart');
const btnMain = document.getElementById('btn-main');
const btnCheck = document.getElementById('btn-check');
const btnHint = document.getElementById('btn-hint');
const btnContinue = document.getElementById('btn-continue');
const scoreEl = document.getElementById('score');
const coachCheck = document.getElementById('coach-check');
const coachMoves = document.getElementById('coach-moves');
const coachContinue = document.getElementById('coach-continue');
const btnInstructions = document.getElementById('btn-instructions');
btnInstructions.addEventListener('click', openIntro);

function placeCoach(coachEl, targetEl, where){
  if(!coachEl || !targetEl) return;
  const r = targetEl.getBoundingClientRect(), pad = 8;
  let left = r.left + r.width/2, top = r.top;
  if(where==='below'){
    coachEl.classList.remove('down'); coachEl.classList.add('up');
    top = r.bottom + 4; left = r.left + r.width/2; coachEl.style.transform = 'translate(-50%, 0)';
  }else if(where==='above'){
    coachEl.classList.remove('up'); coachEl.classList.add('down');
    top = r.top - coachEl.offsetHeight - pad; left = r.left + 16; coachEl.style.transform = 'translate(0, 0)';
  }
  coachEl.style.top = `${Math.max(8, top)}px`; coachEl.style.left = `${Math.max(8, left)}px`;
}
function positionCoaches(){
  placeCoach(coachCheck, btnCheck, 'below');
  placeCoach(coachMoves, document.getElementById('movePicker'), 'above');
  if(!btnContinue.disabled && !coachContinue.classList.contains('hidden')){
    placeCoach(coachContinue, btnContinue, 'below');
  }
}
window.addEventListener('resize', positionCoaches); setTimeout(positionCoaches, 0);

function setScoreCross(v){ scoreEl.textContent = `(number of cross edges in place: ${v}/4)`; }
function toggleContinueCoach(show){
  coachContinue.classList.toggle('hidden', !show);
  if(show) { placeCoach(coachContinue, btnContinue, 'below'); }
}
function lockContinue(lock=true){
  btnContinue.disabled = lock;
  if(lock) btnContinue.setAttribute('aria-disabled','true');
  else btnContinue.removeAttribute('aria-disabled');
  toggleContinueCoach(!lock);
}

btnCheck.addEventListener('click', ()=>{
  const n = countCross();
  setScoreCross(n);
  lockContinue(n!==4);
  if(n>0) flashSolvedEdges(); // <<< glow on solved pieces for ~2s
});

btnHint.addEventListener('click', ()=>{
  const info = firstUnsovledEdgeInfo();
  if(!info){
    showHint(`Cross is <b>already complete</b>. You can hit <b>Continue</b> when ready.`);
    return;
  }
  // Pulse the target edge‚Äôs stickers so the user can spot it
  flashSticker(info.whiteSticker, 2200);
  if(info.otherSticker) flashSticker(info.otherSticker, 2200);
  showHint(info.message);
});

btnContinue.addEventListener('click', ()=>{
  const carryNext = {
    cubies: serializeState(),
    cubeQ: [cubeGroup.quaternion.x, cubeGroup.quaternion.y, cubeGroup.quaternion.z, cubeGroup.quaternion.w]
  };
  localStorage.setItem('erno_after_cross_state_v1', JSON.stringify(carryNext));
  toggleContinueCoach(false);
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Continuing‚Ä¶';
  setTimeout(()=>{ location.href = 'adaptive-tutorial-basics.html'; }, 300);
});

btnMain.addEventListener('click', openConfirm);

btnRestart.addEventListener('click', ()=>{
  cubeGroup.quaternion.set(initialCubeQ[0],initialCubeQ[1],initialCubeQ[2],initialCubeQ[3]);
  applyState(initialCrossState);
  setScoreCross(0);
  lockContinue(true);
});

/* Render loop */
(function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();

/* Intro popup */
const introBackdrop=document.getElementById('introBackdrop');
const introClose=document.getElementById('introClose');
const introStart=document.getElementById('introStart');
function openIntro(){ introBackdrop.classList.add('show'); }
function closeIntro(){ introBackdrop.classList.remove('show'); }
introClose.addEventListener('click', closeIntro);
introStart.addEventListener('click', closeIntro);
introBackdrop.addEventListener('click', (e)=>{ if(e.target===introBackdrop) closeIntro(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && introBackdrop.classList.contains('show')) closeIntro(); });
window.addEventListener('load', ()=>{ setTimeout(openIntro, 700); });
})();
</script>
</body>
</html>
