<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Erno AI — Adaptive Tutorial • Daisy</title>
<style>
:root{
  --bg:#0b0c10; --panel:#121420; --ink:#e8eefc; --muted:#92a0b8; --line:#1b2133; --splashA:#11182a;
  /* derived; populated by JS too */
  --card:#0d1222; --chip:#16213a; --chipBorder:#22325a;
  --btn:#16233e; --btnBorder:#22325a; --accent:#6ea8ff;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
#brand{position:fixed;left:50%;top:12px;transform:translateX(-50%);font-weight:800;font-size:18px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:.4rem .6rem;backdrop-filter:blur(2px);z-index:10}
#topbar{position:fixed;left:12px;top:12px;display:flex;gap:8px;z-index:10}
#topright{position:fixed;right:12px;top:12px;z-index:10}
button{background:var(--btn);border:1px solid var(--btnBorder);color:var(--ink);border-radius:10px;padding:.55rem .8rem;font-weight:800;cursor:pointer}
button:hover{filter:brightness(1.07)}
button:disabled{opacity:.55;filter:grayscale(.2);cursor:not-allowed}

#stage{position:absolute;inset:0}
canvas{display:block;width:100%;height:100%;touch-action:none}

/* Move Picker (theme-flexible, matches tutorial-daisy style) */
#movePicker{
  position:fixed;right:12px;bottom:12px;z-index:21;
  background:var(--card);color:var(--ink);border:1px solid var(--line);
  border-radius:12px;padding:8px;box-shadow:0 10px 24px rgba(0,0,0,.35);min-width:min(720px,92vw);backdrop-filter:blur(2px);
}
#movePicker h3{margin:0 0 6px 0;font-size:13px;font-weight:800}
#score{font-weight:800;margin-left:8px;opacity:.95}
.keygrid{display:flex;flex-wrap:wrap;gap:6px}
.btn-key{
  font-family:ui-monospace,Consolas,monospace;padding:.45rem .65rem;border-radius:10px;border:1px solid var(--btnBorder);
  background:var(--btn);color:var(--ink);font-weight:800;cursor:pointer;transition:filter .15s ease
}
.btn-key:hover{filter:brightness(1.07)}
.btn-key:focus{outline:2px solid #2f4fb3;outline-offset:1px}

/* Splash */
#splash{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 30%, var(--splashA) 0%, var(--bg) 60%);color:var(--ink);z-index:9999;transition:.4s}
#splash.hide{opacity:0;visibility:hidden}
#splash .inner{display:flex;flex-direction:column;align-items:center;gap:12px;text-align:center}
.spinner{width:36px;height:36px;border-radius:50%;border:3px solid rgba(255,255,255,.35);border-top-color:var(--ink);animation:spin .9s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* Themed confirm modal */
.modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.45);display:none; place-items:center; z-index:1000; backdrop-filter:blur(2px);}
.modal{
  width:min(520px,92vw); background:var(--panel); color:var(--ink);
  border:1px solid var(--line); border-radius:14px; padding:16px; box-shadow:0 16px 40px rgba(0,0,0,.45);
}
.modal h3{margin:0 0 6px 0; font-size:18px}
.modal p{margin:0 0 12px 0; color:var(--muted)}
.modal .row{display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap}
.modal .btn{background:var(--btn); border:1px solid var(--btnBorder); color:var(--ink); border-radius:10px; padding:.55rem .9rem; font-weight:800; cursor:pointer;}
.btn-ghost{background:transparent; border:1px solid var(--btnBorder); color:var(--ink);}
.modal-backdrop.show{display:grid}

/* Coach overlays (exact look) */
.coach{
  position:fixed; z-index:2000; pointer-events:none; color:var(--ink);
  font:13px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  display:flex; flex-direction:column; align-items:center;
}
.coach .caption{
  background:var(--panel);
  border:1px solid var(--btnBorder);
  color:var(--ink);
  padding:.30rem .55rem;
  border-radius:8px;
  font-weight:800;
  white-space:nowrap;
  text-wrap:balance;
  max-width:36ch;
}
.coach .arrow{width:0;height:0;margin:4px 0;border:9px solid transparent;animation:bob 1.2s ease-in-out infinite;opacity:.95}
.coach.down .arrow{border-top-color:var(--panel)}
.coach.up   .arrow{border-bottom-color:var(--panel)}
@keyframes bob{0%,100%{transform:translateY(0)}50%{transform:translateY(6px)}}
.hidden{display:none}

/* Intro popup (theme-flexible) */
#introBackdrop{position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); backdrop-filter:blur(2px); z-index:3000;}
#introBackdrop.show{display:grid}
#introCard{
  width:min(940px,94vw); max-height:90vh; overflow:auto;
  background:var(--panel); color:var(--ink);
  border:1px solid var(--line); border-radius:16px; box-shadow:0 24px 64px rgba(0,0,0,.5);
}
#introCard header{position:sticky; top:0; z-index:1; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px; background:var(--panel); border-bottom:1px solid var(--line);}
#introCard h2{margin:0; font-size:20px}
#introClose{background:transparent; border:1px solid var(--btnBorder); padding:.35rem .55rem; border-radius:10px; font-weight:800}
#introBody{padding:16px}
.intro-grid{display:grid; grid-template-columns: 1.1fr 1.4fr; gap:16px}
@media (max-width:900px){ .intro-grid{ grid-template-columns: 1fr } }
.intro-figure{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:10px; display:grid; place-items:center}
.intro-figure img{max-width:100%; height:auto; border-radius:10px}
.intro-copy p{margin:.2rem 0 .7rem 0; color:var(--ink)}
.intro-copy ul{margin:.2rem 0 .8rem 1.1rem; color:var(--muted)}
.intro-foot{position:sticky; bottom:0; background:var(--panel); border-top:1px solid var(--line); padding:12px 16px; display:flex; gap:10px; justify-content:flex-end; align-items:center}
</style>
</head>
<body>
<div id="splash">
  <div class="inner">
    <h1>Erno AI<span style="display:block;opacity:.85;font-size:14px;margin-top:6px">Loading Daisy…</span></h1>
    <div class="spinner" aria-hidden="true"></div>
  </div>
</div>

<div id="brand">Erno AI: Daisy</div>
<div id="topbar">
  <button id="btn-restart" title="Reset to the saved First Steps state">⟲ Restart</button>
  <button id="btn-main">Main Page</button>
  <button id="btn-check">Check Daisy</button>
</div>
<div id="topright">
  <button id="btn-continue" disabled aria-disabled="true" title="Get 4/4 to continue">Continue →</button>
</div>

<div id="stage"><canvas id="view"></canvas></div>

<div id="movePicker" role="group" aria-label="Move Picker">
  <h3>Move Picker <span id="score">(number of white edges in place: 0/4)</span></h3>
  <div id="moveGrid" class="keygrid"></div>
</div>

<!-- Confirm modal -->
<div id="confirmWrap" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmDesc">
    <h3 id="confirmTitle">Leave this tutorial?</h3>
    <p id="confirmDesc">You'll lose your tutorial progress if you leave. Are you sure?</p>
    <div class="row">
      <button id="confirmCancel" class="btn btn-ghost">Cancel</button>
      <button id="confirmOk" class="btn">OK</button>
    </div>
  </div>
</div>

<!-- Coach: same bubbles; continue appears after unlock -->
<div id="coach-check" class="coach up" role="note" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Use this to check your Daisy Progress</div>
</div>
<div id="coach-moves" class="coach down" role="note" aria-live="polite">
  <div class="caption">Use the <b>Move Picker</b> or drag faces to turn the cube</div>
  <div class="arrow" aria-hidden="true"></div>
</div>
<div id="coach-continue" class="coach up hidden" role="status" aria-live="polite">
  <div class="arrow" aria-hidden="true"></div>
  <div class="caption">Congrats! Proceed when you are ready</div>
</div>

<!-- Daisy Intro -->
<div id="introBackdrop" role="dialog" aria-modal="true" aria-labelledby="introTitle" aria-describedby="introDesc">
  <div id="introCard">
    <header>
      <h2 id="introTitle">Step 1: The <span style="color:var(--accent)">Daisy</span></h2>
      <button id="introClose" title="Close">✕</button>
    </header>
    <div id="introBody">
      <div class="intro-grid">
        <figure class="intro-figure">
          <img src="https://images.squarespace-cdn.com/content/v1/54f2df67e4b079e94c291e4f/1427442852968-SDBN9BCCN5PIE9VY71BH/step1_rubiks_cube"
               alt="Illustration of the Daisy: four white edges around the yellow center on the top face.">
        </figure>
        <div class="intro-copy" id="introDesc">
          <p><b>What is the Daisy?</b> Yellow center on top (U) with four <b>white edges</b> around it (white stickers facing up).</p>
          <p><b>Why first?</b> From the Daisy you align each petal above its side color and flip down to build the <b>white cross</b>.</p>
          <ul>
            <li>Keep <b>yellow center on top</b>. Rotate the cube so yellow is up if needed.</li>
            <li>Lift white edges to the top using basic <code>U R L F D B</code> turns (slices optional).</li>
          </ul>
          <p style="color:var(--muted)">Tip: If you knock one out, just put it back. When you have <b>4/4</b>, hit <b>Check Daisy</b> and Continue.</p>
        </div>
      </div>
    </div>
    <div class="intro-foot"><button id="introStart">Got it — Let’s start</button></div>
  </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
/* ===== Theme system (matches tutorial-daisy) ===== */
const STORAGE_KEY='erno_theme_v1';
const THEMES = {
  default:{name:'Midnight (Default)',v:{bg:'#0b0c10',panel:'#121420',ink:'#e8eefc',muted:'#92a0b8',line:'#1b2133',splashA:'#11182a'}},
  cream:{name:'Cream',v:{bg:'#f4efe6',panel:'#fffaf2',ink:'#2c2a25',muted:'#6b665b',line:'#e1d9c9',splashA:'#efe7d8'}},
  caramel:{name:'Caramel',v:{bg:'#2a1f1a',panel:'#3b2b22',ink:'#f8e9d4',muted:'#d9c2a8',line:'#4c3a30',splashA:'#3a2a22'}},
  cyber:{name:'Cyber',v:{bg:'#0a0f0a',panel:'#0f1510',ink:'#d5ffd5',muted:'#90c990',line:'#183018',splashA:'#0f1c10'}},
  nord:{name:'Nord',v:{bg:'#2e3440',panel:'#3b4252',ink:'#eceff4',muted:'#c0c8d5',line:'#4c566a',splashA:'#323a49'}},
  dracula:{name:'Dracula',v:{bg:'#282a36',panel:'#1e2029',ink:'#f8f8f2',muted:'#b6b6c1',line:'#3b3e4b',splashA:'#2f3140'}},
  solarDark:{name:'Solarized Dark',v:{bg:'#002b36',panel:'#073642',ink:'#eee8d5',muted:'#93a1a1',line:'#0b3a46',splashA:'#03313c'}},
  solarLight:{name:'Solarized Light',v:{bg:'#fdf6e3',panel:'#f5efd9',ink:'#073642',muted:'#657b83',line:'#e6dec4',splashA:'#efe8d2'}},
  catMocha:{name:'Catppuccin Mocha',v:{bg:'#1e1e2e',panel:'#242437',ink:'#cdd6f4',muted:'#a6adc8',line:'#313244',splashA:'#23233a'}},
  gruvDark:{name:'Gruvbox Dark',v:{bg:'#1d2021',panel:'#282828',ink:'#ebdbb2',muted:'#d5c4a1',line:'#3c3836',splashA:'#232524'}},
  gruvLight:{name:'Gruvbox Light',v:{bg:'#fbf1c7',panel:'#f2e5bc',ink:'#3c3836',muted:'#7c6f64',line:'#e0d2a4',splashA:'#f5e8bf'}},
  oneDark:{name:'One Dark',v:{bg:'#21252b',panel:'#282c34',ink:'#e6efff',muted:'#a0afc1',line:'#323844',splashA:'#252a31'}},
  synthwave:{name:'Synthwave',v:{bg:'#1b1227',panel:'#231833',ink:'#fedaff',muted:'#d7b6ff',line:'#3a2857',splashA:'#23173a'}},
  monokai:{name:'Monokai',v:{bg:'#272822',panel:'#2e2f27',ink:'#f8f8f2',muted:'#c2c2b4',line:'#3b3c34',splashA:'#2c2d26'}},
  mint:{name:'Mint',v:{bg:'#0e1412',panel:'#111a16',ink:'#d9fff2',muted:'#9de5cf',line:'#173026',splashA:'#15231e'}},
  rosePine:{name:'Rosé Pine',v:{bg:'#191724',panel:'#1f1d2e',ink:'#e0def4',muted:'#908caa',line:'#2a2837',splashA:'#201e2f'}},
  highContrast:{name:'High Contrast',v:{bg:'#000000',panel:'#0a0a0a',ink:'#ffffff',muted:'#bfbfbf',line:'#222222',splashA:'#101010'}},
  mono:{name:'Monochrome',v:{bg:'#111114',panel:'#16171a',ink:'#f1f2f5',muted:'#a9acb3',line:'#272a33',splashA:'#1b1c20'}}
};
function hexToRgb(h){ h=h.replace('#',''); if(h.length===3) h=h.split('').map(c=>c+c).join(''); const n=parseInt(h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
function rgbToHex({r,g,b}){ const n=(r<<16)|(g<<8)|b; return '#'+n.toString(16).padStart(6,'0'); }
function mix(a,b,t){ const A=hexToRgb(a),B=hexToRgb(b); return rgbToHex({r:Math.round(A.r+(B.r-A.r)*t),g:Math.round(A.g+(B.g-A.g)*t),b:Math.round(A.b+(B.b-A.b)*t)}); }
function applyThemeVars(v){
  const rs=document.documentElement.style;
  const card = mix(v.panel, v.bg, 0.15);
  const chip = mix(v.panel, v.line, 0.35);
  const chipBorder = mix(v.line, v.panel, 0.4);
  const btn = mix(v.panel, v.line, 0.25);
  const btnBorder = mix(v.line, v.panel, 0.25);
  const splashA = v.splashA || v.panel;
  const accent = mix(v.ink, v.panel, 0.2);

  rs.setProperty('--bg', v.bg);
  rs.setProperty('--panel', v.panel);
  rs.setProperty('--ink', v.ink);
  rs.setProperty('--muted', v.muted);
  rs.setProperty('--line', v.line);
  rs.setProperty('--splashA', splashA);
  rs.setProperty('--card', card);
  rs.setProperty('--chip', chip);
  rs.setProperty('--chipBorder', chipBorder);
  rs.setProperty('--btn', btn);
  rs.setProperty('--btnBorder', btnBorder);
  rs.setProperty('--accent', accent);
}
function applyThemeById(id){ const t = THEMES[id] || THEMES.default; applyThemeVars(t.v); }
applyThemeById(localStorage.getItem(STORAGE_KEY) || 'default');
window.addEventListener('storage', (e)=>{ if(e.key===STORAGE_KEY) applyThemeById(e.newValue || 'default'); });

const splash=document.getElementById('splash');
function hideSplash(){ splash.classList.add('hide'); setTimeout(()=>splash.remove(),800); }
window.addEventListener('load', ()=> setTimeout(hideSplash, 400));

/* ===== Modal for Main ===== */
const modal = document.getElementById('confirmWrap');
const okBtn = document.getElementById('confirmOk');
const cancelBtn = document.getElementById('confirmCancel');
function openConfirm(){ modal.classList.add('show'); modal.setAttribute('aria-hidden','false'); okBtn.focus(); }
function closeConfirm(){ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
modal.addEventListener('click', (e)=>{ if(e.target === modal) closeConfirm(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.classList.contains('show')) closeConfirm(); });
okBtn.addEventListener('click', ()=>{
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Returning to Main Page…';
  modal.classList.remove('show');
  setTimeout(()=>{ location.href = 'adaptive-move-picker.html'; }, 300);
});
cancelBtn.addEventListener('click', closeConfirm);

/* ===== Scene (Adaptive engine from First Steps) ===== */
const canvas = document.getElementById('view');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50,1,.1,1000);
const CAM_INIT_POS = new THREE.Vector3(5.2, 4.7, 6.1);
const CAM_INIT_TARGET = new THREE.Vector3(0, 0, 0);
function resetView(){ camera.up.set(0,1,0); camera.position.copy(CAM_INIT_POS); camera.lookAt(CAM_INIT_TARGET); }
resetView();
scene.add(camera);
scene.add(new THREE.AmbientLight(0xffffff,.6));
const key = new THREE.DirectionalLight(0xffffff,.9); key.position.set(3,6,7); scene.add(key);
const stage = document.getElementById('stage');
new ResizeObserver(()=>{ const w=stage.clientWidth,h=stage.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();}).observe(stage);

/* Background grid panes */
(function(size=600,div=120,color=0x223355,opacity=0.07){
  const mk=()=>{const gh=new THREE.GridHelper(size,div,color,color);gh.material.transparent=true;gh.material.opacity=opacity;return gh};
  const g=new THREE.Group(), xz1=mk(), xz2=mk(), xy1=mk(), xy2=mk(), yz1=mk(), yz2=mk();
  xz1.position.y=size/2; xz2.position.y=-size/2;
  xy1.rotation.x=Math.PI/2; xy1.position.z=size/2; xy2.rotation.x=Math.PI/2; xy2.position.z=-size/2;
  yz1.rotation.z=Math.PI/2; yz1.position.x=size/2; yz2.rotation.z=Math.PI/2; yz2.position.x=-size/2;
  g.add(xz1,xz2,xy1,xy2,yz1,yz2); scene.add(g);
})();

/* Build cubies (stickers include userData.localNormal like tutorial-daisy) */
const cubeGroup = new THREE.Group(); scene.add(cubeGroup);
let cubies=[]; const CELL=1, STICKER=.92, GAP=.04;
const COLORS={ U:0xffd500, D:0xffffff, L:0xcc0000, R:0xff8c1a, F:0x00a040, B:0x0040cc };
function mkCubie(i,j,k){
  const core = new THREE.Mesh(new THREE.BoxGeometry(STICKER,STICKER,STICKER), new THREE.MeshStandardMaterial({color:0x111317,roughness:.9}));
  const g=new THREE.Group(); g.add(core); g.position.set(i*CELL,j*CELL,k*CELL);
  const faces=[
    {key:'R',show:i=== 1,n:new THREE.Vector3( 1,0,0)},
    {key:'L',show:i===-1,n:new THREE.Vector3(-1,0,0)},
    {key:'U',show:j=== 1,n:new THREE.Vector3( 0,1,0)},
    {key:'D',show:j===-1,n:new THREE.Vector3( 0,-1,0)},
    {key:'F',show:k=== 1,n:new THREE.Vector3( 0,0,1)},
    {key:'B',show:k===-1,n:new THREE.Vector3( 0,0,-1)}
  ];
  const pg=new THREE.PlaneGeometry(STICKER-GAP,STICKER-GAP);
  faces.forEach(f=>{
    if(!f.show) return;
    const s=new THREE.Mesh(pg,new THREE.MeshBasicMaterial({color:COLORS[f.key]}));
    s.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), f.n);
    s.position.copy(f.n).multiplyScalar(STICKER/2+0.001);
    s.userData = { isSticker:true, faceKey:f.key, localNormal:f.n.clone() };
    g.add(s);
  });
  cubeGroup.add(g); cubies.push(g);
}
(function build(){ for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) for(let k=-1;k<=1;k++) mkCubie(i,j,k); })();

/* Orbit (RMB or Shift+LMB) */
let orbit=false, px=0, py=0;
canvas.addEventListener('contextmenu',e=>e.preventDefault(), {passive:false});
canvas.addEventListener('pointerdown',e=>{
  if(e.pointerType!=='mouse') return;
  if(e.button===2||(e.button===0&&e.shiftKey)){ orbit=true; px=e.clientX; py=e.clientY; }
},{passive:false});
canvas.addEventListener('pointerup',()=>{orbit=false;},{passive:false});
canvas.addEventListener('pointerleave',()=>{orbit=false;},{passive:false});
function orbitStep(dx,dy){
  const sp=0.005, target=CAM_INIT_TARGET.clone();
  const f=new THREE.Vector3(); camera.getWorldDirection(f);
  const worldUp=new THREE.Vector3(0,1,0);
  const qYaw=new THREE.Quaternion().setFromAxisAngle(worldUp, -dx*sp);
  const rightV=new THREE.Vector3().crossVectors(f,camera.up).normalize();
  const safeRight= rightV.lengthSq()>1e-8 ? rightV : new THREE.Vector3(1,0,0);
  const qPitch=new THREE.Quaternion().setFromAxisAngle(safeRight, -dy*sp);
  const q=new THREE.Quaternion().multiply(qYaw).multiply(qPitch);
  const off=camera.position.clone().sub(target).applyQuaternion(q);
  camera.up.applyQuaternion(q);
  camera.position.copy(target.add(off));
  camera.lookAt(CAM_INIT_TARGET);
}
canvas.addEventListener('pointermove',e=>{
  if(!orbit) return;
  const dx=e.clientX-px, dy=e.clientY-py; px=e.clientX; py=e.clientY;
  orbitStep(dx,dy); renderer.render(scene,camera);
},{passive:false});
window.addEventListener('wheel',e=>{ camera.position.multiplyScalar(1+Math.sign(e.deltaY)*.08).clampLength(4,40); },{passive:true});

/* Turn engine (Adaptive) */
const AX={x:new THREE.Vector3(1,0,0), y:new THREE.Vector3(0,1,0), z:new THREE.Vector3(0,0,1)};
let turning=false;
function animateTo(pivot, axisVec, start, target, sel, done){
  turning=true;
  const dur=160, t0=performance.now();
  const tick=t=>{
    const k=Math.min(1,(t-t0)/dur), ang=start+(target-start)*k;
    pivot.setRotationFromAxisAngle(axisVec,ang);
    renderer.render(scene,camera);
    if(k<1) requestAnimationFrame(tick);
    else{
      pivot.updateMatrixWorld(true);
      for(const c of sel){ cubeGroup.attach(c); c.position.set(Math.round(c.position.x),Math.round(c.position.y),Math.round(c.position.z)); }
      cubeGroup.remove(pivot); turning=false; done&&done();
    }
  };
  requestAnimationFrame(tick);
}
function select(axis,layer){ const out=[]; for(const c of cubies){ const v=axis==='x'?c.position.x:axis==='y'?c.position.y:c.position.z; if(Math.round(v)===layer) out.push(c);} return out; }
function rotate(axis,layer,sign,cb){ if(turning) return; const sel=select(axis,layer); const pivot=new THREE.Group(); cubeGroup.add(pivot); sel.forEach(c=>pivot.attach(c)); animateTo(pivot,AX[axis],0,sign*(Math.PI/2),sel,cb); }

/* Whole-cube rotations so UI stays view-relative */
function rotateWhole(axis,sign,reps,cb){
  if(turning) return;
  const dur=160, quarter=sign*(Math.PI/2);
  const step=(left)=>{
    if(left<=0){ cb&&cb(); return; }
    turning=true;
    const startQ=cubeGroup.quaternion.clone();
    const targetQ=new THREE.Quaternion().setFromAxisAngle(AX[axis], quarter);
    const t0=performance.now();
    const tick=t=>{
      const k=Math.min(1,(t-t0)/dur);
      const qStep=new THREE.Quaternion().setFromAxisAngle(AX[axis], quarter*k);
      cubeGroup.quaternion.copy(startQ.clone().multiply(qStep));
      renderer.render(scene,camera);
      if(k<1) requestAnimationFrame(tick);
      else { cubeGroup.quaternion.copy(startQ.clone().multiply(targetQ)); turning=false; step(left-1); }
    };
    requestAnimationFrame(tick);
  };
  step(reps||1);
}

/* Drag-to-turn (cube-local) */
const ray=new THREE.Raycaster(), ndc=new THREE.Vector2();
const toNDC=e=>{ const r=canvas.getBoundingClientRect(); ndc.x=((e.clientX-r.left)/r.width)*2-1; ndc.y=-((e.clientY-r.top)/r.height)*2+1; };
function pick(e){
  toNDC(e); ray.setFromCamera(ndc,camera);
  const hit=ray.intersectObjects(cubeGroup.children,true)[0];
  if(!hit) return null;
  let root=hit.object; while(root && root.parent!==cubeGroup) root=root.parent;
  const n=hit.face?hit.face.normal.clone().transformDirection(hit.object.matrixWorld):new THREE.Vector3(0,0,1).applyQuaternion(hit.object.getWorldQuaternion(new THREE.Quaternion()));
  return {cubie:root,normal:n.normalize()};
}
function camBasis(){ const f=new THREE.Vector3(); camera.getWorldDirection(f).normalize(); const r=new THREE.Vector3().crossVectors(f,camera.up).normalize(); const u=new THREE.Vector3().crossVectors(r,f).normalize(); return {f,r,u}; }
const AXV={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};
const drag={active:false,sx:0,sy:0,axis:null,layer:0,sel:[],pivot:null,plus:null,angle:0};
function resetDrag(){ drag.active=false; drag.axis=null; drag.layer=0; drag.sel=[]; drag.pivot=null; drag.plus=null; drag.angle=0; }
const AXIS_LOCK_FACE=36, AXIS_LOCK_SLICE=9, SNAP_FRAC_FACE=.10, SNAP_FRAC_SLICE=.08, HALF=.75;

canvas.addEventListener('pointerdown',e=>{
  if(e.pointerType==='mouse' && e.button!==0) return;
  if(turning) return;
  const info=pick(e); if(!info) return;
  drag.active=true; drag.sx=e.clientX; drag.sy=e.clientY; drag.axis=null; drag.hit=info;
});
canvas.addEventListener('pointermove',e=>{
  if(!drag.active||turning) return;
  const dx=e.clientX-drag.sx, dy=e.clientY-drag.sy, d2=dx*dx+dy*dy;

  const invQ=cubeGroup.getWorldQuaternion(new THREE.Quaternion()).invert();
  const n=drag.hit.normal.clone().applyQuaternion(invQ);

  if(!drag.axis){
    const cand=Math.abs(n.x)>0.8?['y','z']:Math.abs(n.y)>0.8?['x','z']:['x','y'];
    const {r,u}=camBasis();
    const dragWorld=new THREE.Vector3().addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
    const dragLocal=dragWorld.applyQuaternion(invQ).normalize();

    let axis=cand[0], best=-1;
    for(const a of cand){ const s=Math.abs(dragLocal.dot(AXV[a])); if(s>best){best=s; axis=a;} }

    const info2=pick(e); if(!info2) return;
    const layerGuess=Math.max(-1,Math.min(1,Math.round(axis==='x'?info2.cubie.position.x:axis==='y'?info2.cubie.position.y:info2.cubie.position.z)));
    const need=(layerGuess===0?AXIS_LOCK_SLICE:AXIS_LOCK_FACE); if(d2<need) return;

    drag.axis=axis; drag.layer=layerGuess;
    drag.sel=select(axis,layerGuess);
    drag.pivot=new THREE.Group(); cubeGroup.add(drag.pivot); drag.sel.forEach(cu=>drag.pivot.attach(cu));
    drag.plus=new THREE.Vector3().crossVectors(n,AXV[axis]).normalize();
  }

  const {r,u}=camBasis();
  const dragWorld=new THREE.Vector3().addScaledVector(r,dx).addScaledVector(u,-dy).normalize();
  const dragLocal=dragWorld.applyQuaternion(invQ).normalize();
  const s=dragLocal.dot(drag.plus);
  drag.angle=THREE.MathUtils.clamp(s*Math.PI,-3.2,3.2);
  drag.pivot.setRotationFromAxisAngle(AXV[drag.axis], drag.angle);
  renderer.render(scene,camera);
});
function commitOrCancel(){
  if(!drag.axis || !drag.pivot){ resetDrag(); return; }
  const q=Math.PI/2, a=Math.abs(drag.angle);
  const frac=(drag.layer===0?SNAP_FRAC_SLICE:SNAP_FRAC_FACE);
  if(a<q*frac){ animateTo(drag.pivot, AXV[drag.axis], drag.angle, 0, drag.sel, ()=>resetDrag()); }
  else{
    let reps, sign;
    if(a>=Math.PI*HALF){ reps=2; sign=(drag.angle>0)?+1:-1; } else { reps=1; sign=(drag.angle>0)?+1:-1; }
    const go=(left)=>{ if(left<=0){ resetDrag(); return; } animateTo(drag.pivot, AXV[drag.axis], left===reps?drag.angle:0, sign*(Math.PI/2), drag.sel, ()=>go(left-1)); };
    go(reps);
  }
}
window.addEventListener('pointerup',()=>{ if(drag.active) commitOrCancel(); });
canvas.addEventListener('pointercancel',()=>{ if(drag.active) commitOrCancel(); });

/* Adaptive mapping + Move Picker (screen-relative) */
function majorAxis(v){ const ax=Math.abs(v.x), ay=Math.abs(v.y), az=Math.abs(v.z);
  if(ax>=ay&&ax>=az) return {axis:'x',sgn:v.x>=0?+1:-1};
  if(ay>=ax&&ay>=az) return {axis:'y',sgn:v.y>=0?+1:-1};
  return {axis:'z',sgn:v.z>=0?+1:-1}; }
function camBasis(){ const f=new THREE.Vector3(); camera.getWorldDirection(f).normalize(); const r=new THREE.Vector3().crossVectors(f,camera.up).normalize(); const u=new THREE.Vector3().crossVectors(r,f).normalize(); return {f,r,u}; }
function viewMapping(){
  const {f,r,u}=camBasis();
  const invQ=cubeGroup.getWorldQuaternion(new THREE.Quaternion()).invert();
  const rL=r.clone().applyQuaternion(invQ), uL=u.clone().applyQuaternion(invQ), fL=new THREE.Vector3(-f.x,-f.y,-f.z).applyQuaternion(invQ);
  const Rm=majorAxis(rL), Um=majorAxis(uL), Fm=majorAxis(fL);
  const map={
    R:{axis:Rm.axis, layer:Rm.sgn>0?+1:-1, sgn:Rm.sgn}, L:{axis:Rm.axis, layer:Rm.sgn>0?-1:+1, sgn:-Rm.sgn},
    U:{axis:Um.axis, layer:Um.sgn>0?+1:-1, sgn:Um.sgn}, D:{axis:Um.axis, layer:Um.sgn>0?-1:+1, sgn:-Um.sgn},
    F:{axis:Fm.axis, layer:Fm.sgn>0?+1:-1, sgn:Fm.sgn}, B:{axis:Fm.axis, layer:Fm.sgn>0?-1:+1, sgn:-Fm.sgn}
  };
  map.M={axis:map.R.axis, layer:0, sgn:map.L.sgn};
  map.E={axis:map.U.axis, layer:0, sgn:map.D.sgn};
  map.S={axis:map.F.axis, layer:0, sgn:map.F.sgn};
  return map;
}
function moveToAction(letter,suffix){
  const M=viewMapping()[letter];
  let reps=1, cw=true;
  if(suffix==="2"){ reps=2; cw=true; }
  else if(suffix=="'"){ cw=false; }
  if(letter==='E'||letter==='S'||letter==='M') cw=!cw;
  const isSlice=(letter==='M'||letter==='E'||letter==='S');
  const sign=isSlice ? (cw?+M.sgn:-M.sgn) : (cw?-M.sgn:+M.sgn);
  return {axis:M.axis, layer:M.layer, sign, reps};
}
const labels=["R","R'","U","U'","F","F'","L","L'","D","D'","B","B'","M","M'","E","E'","S","S'"];
const moveGrid=document.getElementById('moveGrid');
function applyLabel(lbl,cb){
  if(turning) return;
  const m=/^([RULDFBMESxyz])([2']?)$/.exec(lbl); if(!m) return;
  const letter=m[1], suf=m[2]||'';
  if('xyz'.includes(letter)){
    const axis=letter, reps=(suf==='2')?2:1, sign=(suf=="'")?+1:-1;
    rotateWhole(axis,sign,reps,cb);
  }else{
    const a=moveToAction(letter,suf);
    const go=(left)=>{ if(left<=0){cb&&cb(); return;} rotate(a.axis,a.layer,a.sign, ()=>go(left-1)); }; go(a.reps);
  }
}
labels.forEach(lbl=>{ const b=document.createElement('button'); b.className='btn-key'; b.textContent=lbl; b.addEventListener('click',()=>applyLabel(lbl)); moveGrid.appendChild(b); });

/* ===== State I/O ===== */
function serializeState(){ return cubies.map(c=>({ p:[c.position.x,c.position.y,c.position.z], q:[c.quaternion.x,c.quaternion.y,c.quaternion.z,c.quaternion.w] })); }
function applyState(state){
  if(!state || state.length!==cubies.length) return false;
  for(let i=0;i<cubies.length;i++){
    const it=state[i], c=cubies[i];
    c.position.set(Math.round(it.p[0]), Math.round(it.p[1]), Math.round(it.p[2]));
    c.quaternion.set(it.q[0],it.q[1],it.q[2],it.q[3]);
    c.updateMatrixWorld(true);
  }
  return true;
}
function loadJSON(key){ try{ return JSON.parse(localStorage.getItem(key)||''); }catch(_){ return null; } }
const initialState = loadJSON('erno_firststeps_leave_state_v1') || loadJSON('erno_scramble_state_v1');
if(initialState) applyState(initialState);

/* ===== Daisy check (identical logic) ===== */
const WHITE = 0xffffff, YELLOW = 0xffd500;
function findCubieAt(x,y,z){ for(const c of cubies){ if(Math.round(c.position.x)===x && Math.round(c.position.y)===y && Math.round(c.position.z)===z) return c;} return null; }
function stickerFacingUpColor(cubie){
  if(!cubie) return null;
  const q = cubie.getWorldQuaternion(new THREE.Quaternion());
  for(const ch of cubie.children){
    if(!ch.userData?.isSticker) continue;
    const n = ch.userData.localNormal.clone().applyQuaternion(q).normalize();
    if(n.y > 0.95) return ch.material.color.getHex();
  }
  return null;
}
function yellowCenterOnTop(){ const center = findCubieAt(0,1,0); const col = stickerFacingUpColor(center); return col === YELLOW; }
function countDaisy(){
  if(!yellowCenterOnTop()) return 0;
  const targets=[ findCubieAt( 1,1,0), findCubieAt(-1,1,0), findCubieAt(0,1, 1), findCubieAt(0,1,-1) ];
  let c=0; for(const e of targets){ const col = stickerFacingUpColor(e); if(col === WHITE) c++; } return c;
}

/* ===== UI wiring (continue coach exact behavior) ===== */
const btnRestart = document.getElementById('btn-restart');
const btnMain = document.getElementById('btn-main');
const btnCheck = document.getElementById('btn-check');
const btnContinue = document.getElementById('btn-continue');
const scoreEl = document.getElementById('score');
const coachCheck = document.getElementById('coach-check');
const coachMoves = document.getElementById('coach-moves');
const coachContinue = document.getElementById('coach-continue');

function placeCoach(coachEl, targetEl, where){
  if(!coachEl || !targetEl) return;
  const r = targetEl.getBoundingClientRect(), pad = 8;
  let left = r.left + r.width/2, top = r.top;
  if(where==='below'){
    coachEl.classList.remove('down'); coachEl.classList.add('up');
    top = r.bottom + 4; left = r.left + r.width/2; coachEl.style.transform = 'translate(-50%, 0)';
  }else if(where==='above'){
    coachEl.classList.remove('up'); coachEl.classList.add('down');
    top = r.top - coachEl.offsetHeight - pad; left = r.left + 16; coachEl.style.transform = 'translate(0, 0)';
  }
  coachEl.style.top = `${Math.max(8, top)}px`; coachEl.style.left = `${Math.max(8, left)}px`;
}
function positionCoaches(){
  placeCoach(coachCheck, btnCheck, 'below');
  placeCoach(coachMoves, document.getElementById('movePicker'), 'above');
  if(!btnContinue.disabled && !coachContinue.classList.contains('hidden')){
    placeCoach(coachContinue, btnContinue, 'below');
  }
}
window.addEventListener('resize', positionCoaches); setTimeout(positionCoaches, 0);

function setScore(v){ scoreEl.textContent = `(number of white edges in place: ${v}/4)`; }
function toggleContinueCoach(show){
  coachContinue.classList.toggle('hidden', !show);
  if(show) { placeCoach(coachContinue, btnContinue, 'below'); }
}
function lockContinue(lock=true){
  btnContinue.disabled = lock;
  if(lock) btnContinue.setAttribute('aria-disabled','true');
  else btnContinue.removeAttribute('aria-disabled');
  toggleContinueCoach(!lock);   // show coach only when unlocked
}

btnCheck.addEventListener('click', ()=>{
  const n = countDaisy();
  setScore(n);
  if(n===4){ lockContinue(false); }
  else{ lockContinue(true); }
});

btnContinue.addEventListener('click', ()=>{
  toggleContinueCoach(false);
  document.body.appendChild(splash);
  splash.querySelector('span').textContent = 'Continuing…';
  setTimeout(()=>{ location.href = 'adaptive-tutorial-basics.html'; }, 300);
});
btnMain.addEventListener('click', openConfirm);

btnRestart.addEventListener('click', ()=>{
  if(initialState) applyState(initialState);
  setScore(0);
  lockContinue(true);
});

/* Render loop */
(function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();

/* Intro popup */
const introBackdrop=document.getElementById('introBackdrop');
const introClose=document.getElementById('introClose');
const introStart=document.getElementById('introStart');
function openIntro(){ introBackdrop.classList.add('show'); }
function closeIntro(){ introBackdrop.classList.remove('show'); }
introClose.addEventListener('click', closeIntro);
introStart.addEventListener('click', closeIntro);
introBackdrop.addEventListener('click', (e)=>{ if(e.target===introBackdrop) closeIntro(); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && introBackdrop.classList.contains('show')) closeIntro(); });
window.addEventListener('load', ()=>{ setTimeout(openIntro, 700); });
})();
</script>
</body>
</html>
